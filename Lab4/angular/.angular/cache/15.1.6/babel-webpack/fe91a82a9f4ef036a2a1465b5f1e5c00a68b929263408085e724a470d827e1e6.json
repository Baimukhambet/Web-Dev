{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { isSingleExpression } from './directive-helpers.js';\nimport { Directive, PartType } from './directive.js';\nexport * from './directive.js';\nconst DEV_MODE = true;\n/**\n * Recursively walks down the tree of Parts/TemplateInstances/Directives to set\n * the connected state of directives and run `disconnected`/ `reconnected`\n * callbacks.\n *\n * @return True if there were children to disconnect; false otherwise\n */\nconst notifyChildrenConnectedChanged = (parent, isConnected) => {\n  var _a, _b;\n  const children = parent._$disconnectableChildren;\n  if (children === undefined) {\n    return false;\n  }\n  for (const obj of children) {\n    // The existence of `_$notifyDirectiveConnectionChanged` is used as a \"brand\" to\n    // disambiguate AsyncDirectives from other DisconnectableChildren\n    // (as opposed to using an instanceof check to know when to call it); the\n    // redundancy of \"Directive\" in the API name is to avoid conflicting with\n    // `_$notifyConnectionChanged`, which exists `ChildParts` which are also in\n    // this list\n    // Disconnect Directive (and any nested directives contained within)\n    // This property needs to remain unminified.\n    (_b = (_a = obj)['_$notifyDirectiveConnectionChanged']) === null || _b === void 0 ? void 0 : _b.call(_a, isConnected, false);\n    // Disconnect Part/TemplateInstance\n    notifyChildrenConnectedChanged(obj, isConnected);\n  }\n  return true;\n};\n/**\n * Removes the given child from its parent list of disconnectable children, and\n * if the parent list becomes empty as a result, removes the parent from its\n * parent, and so forth up the tree when that causes subsequent parent lists to\n * become empty.\n */\nconst removeDisconnectableFromParent = obj => {\n  let parent, children;\n  do {\n    if ((parent = obj._$parent) === undefined) {\n      break;\n    }\n    children = parent._$disconnectableChildren;\n    children.delete(obj);\n    obj = parent;\n  } while ((children === null || children === void 0 ? void 0 : children.size) === 0);\n};\nconst addDisconnectableToParent = obj => {\n  // Climb the parent tree, creating a sparse tree of children needing\n  // disconnection\n  for (let parent; parent = obj._$parent; obj = parent) {\n    let children = parent._$disconnectableChildren;\n    if (children === undefined) {\n      parent._$disconnectableChildren = children = new Set();\n    } else if (children.has(obj)) {\n      // Once we've reached a parent that already contains this child, we\n      // can short-circuit\n      break;\n    }\n    children.add(obj);\n    installDisconnectAPI(parent);\n  }\n};\n/**\n * Changes the parent reference of the ChildPart, and updates the sparse tree of\n * Disconnectable children accordingly.\n *\n * Note, this method will be patched onto ChildPart instances and called from\n * the core code when parts are moved between different parents.\n */\nfunction reparentDisconnectables(newParent) {\n  if (this._$disconnectableChildren !== undefined) {\n    removeDisconnectableFromParent(this);\n    this._$parent = newParent;\n    addDisconnectableToParent(this);\n  } else {\n    this._$parent = newParent;\n  }\n}\n/**\n * Sets the connected state on any directives contained within the committed\n * value of this part (i.e. within a TemplateInstance or iterable of\n * ChildParts) and runs their `disconnected`/`reconnected`s, as well as within\n * any directives stored on the ChildPart (when `valueOnly` is false).\n *\n * `isClearingValue` should be passed as `true` on a top-level part that is\n * clearing itself, and not as a result of recursively disconnecting directives\n * as part of a `clear` operation higher up the tree. This both ensures that any\n * directive on this ChildPart that produced a value that caused the clear\n * operation is not disconnected, and also serves as a performance optimization\n * to avoid needless bookkeeping when a subtree is going away; when clearing a\n * subtree, only the top-most part need to remove itself from the parent.\n *\n * `fromPartIndex` is passed only in the case of a partial `_clear` running as a\n * result of truncating an iterable.\n *\n * Note, this method will be patched onto ChildPart instances and called from the\n * core code when parts are cleared or the connection state is changed by the\n * user.\n */\nfunction notifyChildPartConnectedChanged(isConnected, isClearingValue = false, fromPartIndex = 0) {\n  const value = this._$committedValue;\n  const children = this._$disconnectableChildren;\n  if (children === undefined || children.size === 0) {\n    return;\n  }\n  if (isClearingValue) {\n    if (Array.isArray(value)) {\n      // Iterable case: Any ChildParts created by the iterable should be\n      // disconnected and removed from this ChildPart's disconnectable\n      // children (starting at `fromPartIndex` in the case of truncation)\n      for (let i = fromPartIndex; i < value.length; i++) {\n        notifyChildrenConnectedChanged(value[i], false);\n        removeDisconnectableFromParent(value[i]);\n      }\n    } else if (value != null) {\n      // TemplateInstance case: If the value has disconnectable children (will\n      // only be in the case that it is a TemplateInstance), we disconnect it\n      // and remove it from this ChildPart's disconnectable children\n      notifyChildrenConnectedChanged(value, false);\n      removeDisconnectableFromParent(value);\n    }\n  } else {\n    notifyChildrenConnectedChanged(this, isConnected);\n  }\n}\n/**\n * Patches disconnection API onto ChildParts.\n */\nconst installDisconnectAPI = obj => {\n  var _a, _b;\n  var _c, _d;\n  if (obj.type == PartType.CHILD) {\n    (_a = (_c = obj)._$notifyConnectionChanged) !== null && _a !== void 0 ? _a : _c._$notifyConnectionChanged = notifyChildPartConnectedChanged;\n    (_b = (_d = obj)._$reparentDisconnectables) !== null && _b !== void 0 ? _b : _d._$reparentDisconnectables = reparentDisconnectables;\n  }\n};\n/**\n * An abstract `Directive` base class whose `disconnected` method will be\n * called when the part containing the directive is cleared as a result of\n * re-rendering, or when the user calls `part.setConnected(false)` on\n * a part that was previously rendered containing the directive (as happens\n * when e.g. a LitElement disconnects from the DOM).\n *\n * If `part.setConnected(true)` is subsequently called on a\n * containing part, the directive's `reconnected` method will be called prior\n * to its next `update`/`render` callbacks. When implementing `disconnected`,\n * `reconnected` should also be implemented to be compatible with reconnection.\n *\n * Note that updates may occur while the directive is disconnected. As such,\n * directives should generally check the `this.isConnected` flag during\n * render/update to determine whether it is safe to subscribe to resources\n * that may prevent garbage collection.\n */\nexport class AsyncDirective extends Directive {\n  constructor() {\n    super(...arguments);\n    // @internal\n    this._$disconnectableChildren = undefined;\n  }\n  /**\n   * Initialize the part with internal fields\n   * @param part\n   * @param parent\n   * @param attributeIndex\n   */\n  _$initialize(part, parent, attributeIndex) {\n    super._$initialize(part, parent, attributeIndex);\n    addDisconnectableToParent(this);\n    this.isConnected = part._$isConnected;\n  }\n  // This property needs to remain unminified.\n  /**\n   * Called from the core code when a directive is going away from a part (in\n   * which case `shouldRemoveFromParent` should be true), and from the\n   * `setChildrenConnected` helper function when recursively changing the\n   * connection state of a tree (in which case `shouldRemoveFromParent` should\n   * be false).\n   *\n   * @param isConnected\n   * @param isClearingDirective - True when the directive itself is being\n   *     removed; false when the tree is being disconnected\n   * @internal\n   */\n  ['_$notifyDirectiveConnectionChanged'](isConnected, isClearingDirective = true) {\n    var _a, _b;\n    if (isConnected !== this.isConnected) {\n      this.isConnected = isConnected;\n      if (isConnected) {\n        (_a = this.reconnected) === null || _a === void 0 ? void 0 : _a.call(this);\n      } else {\n        (_b = this.disconnected) === null || _b === void 0 ? void 0 : _b.call(this);\n      }\n    }\n    if (isClearingDirective) {\n      notifyChildrenConnectedChanged(this, isConnected);\n      removeDisconnectableFromParent(this);\n    }\n  }\n  /**\n   * Sets the value of the directive's Part outside the normal `update`/`render`\n   * lifecycle of a directive.\n   *\n   * This method should not be called synchronously from a directive's `update`\n   * or `render`.\n   *\n   * @param directive The directive to update\n   * @param value The value to set\n   */\n  setValue(value) {\n    if (isSingleExpression(this.__part)) {\n      this.__part._$setValue(value, this);\n    } else {\n      // this.__attributeIndex will be defined in this case, but\n      // assert it in dev mode\n      if (DEV_MODE && this.__attributeIndex === undefined) {\n        throw new Error(`Expected this.__attributeIndex to be a number`);\n      }\n      const newValues = [...this.__part._$committedValue];\n      newValues[this.__attributeIndex] = value;\n      this.__part._$setValue(newValues, this, 0);\n    }\n  }\n  /**\n   * User callbacks for implementing logic to release any resources/subscriptions\n   * that may have been retained by this directive. Since directives may also be\n   * re-connected, `reconnected` should also be implemented to restore the\n   * working state of the directive prior to the next render.\n   */\n  disconnected() {}\n  reconnected() {}\n}","map":{"version":3,"names":["isSingleExpression","Directive","PartType","DEV_MODE","notifyChildrenConnectedChanged","parent","isConnected","_a","_b","children","_$disconnectableChildren","undefined","obj","call","removeDisconnectableFromParent","_$parent","delete","size","addDisconnectableToParent","Set","has","add","installDisconnectAPI","reparentDisconnectables","newParent","notifyChildPartConnectedChanged","isClearingValue","fromPartIndex","value","_$committedValue","Array","isArray","i","length","_c","_d","type","CHILD","_$notifyConnectionChanged","_$reparentDisconnectables","AsyncDirective","constructor","arguments","_$initialize","part","attributeIndex","_$isConnected","isClearingDirective","reconnected","disconnected","setValue","__part","_$setValue","__attributeIndex","Error","newValues"],"sources":["/Users/tima/kbtu/4thSemester/web/Lab4/angular/node_modules/lit-html/development/async-directive.js"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { isSingleExpression } from './directive-helpers.js';\nimport { Directive, PartType } from './directive.js';\nexport * from './directive.js';\nconst DEV_MODE = true;\n/**\n * Recursively walks down the tree of Parts/TemplateInstances/Directives to set\n * the connected state of directives and run `disconnected`/ `reconnected`\n * callbacks.\n *\n * @return True if there were children to disconnect; false otherwise\n */\nconst notifyChildrenConnectedChanged = (parent, isConnected) => {\n    var _a, _b;\n    const children = parent._$disconnectableChildren;\n    if (children === undefined) {\n        return false;\n    }\n    for (const obj of children) {\n        // The existence of `_$notifyDirectiveConnectionChanged` is used as a \"brand\" to\n        // disambiguate AsyncDirectives from other DisconnectableChildren\n        // (as opposed to using an instanceof check to know when to call it); the\n        // redundancy of \"Directive\" in the API name is to avoid conflicting with\n        // `_$notifyConnectionChanged`, which exists `ChildParts` which are also in\n        // this list\n        // Disconnect Directive (and any nested directives contained within)\n        // This property needs to remain unminified.\n        (_b = (_a = obj)['_$notifyDirectiveConnectionChanged']) === null || _b === void 0 ? void 0 : _b.call(_a, isConnected, false);\n        // Disconnect Part/TemplateInstance\n        notifyChildrenConnectedChanged(obj, isConnected);\n    }\n    return true;\n};\n/**\n * Removes the given child from its parent list of disconnectable children, and\n * if the parent list becomes empty as a result, removes the parent from its\n * parent, and so forth up the tree when that causes subsequent parent lists to\n * become empty.\n */\nconst removeDisconnectableFromParent = (obj) => {\n    let parent, children;\n    do {\n        if ((parent = obj._$parent) === undefined) {\n            break;\n        }\n        children = parent._$disconnectableChildren;\n        children.delete(obj);\n        obj = parent;\n    } while ((children === null || children === void 0 ? void 0 : children.size) === 0);\n};\nconst addDisconnectableToParent = (obj) => {\n    // Climb the parent tree, creating a sparse tree of children needing\n    // disconnection\n    for (let parent; (parent = obj._$parent); obj = parent) {\n        let children = parent._$disconnectableChildren;\n        if (children === undefined) {\n            parent._$disconnectableChildren = children = new Set();\n        }\n        else if (children.has(obj)) {\n            // Once we've reached a parent that already contains this child, we\n            // can short-circuit\n            break;\n        }\n        children.add(obj);\n        installDisconnectAPI(parent);\n    }\n};\n/**\n * Changes the parent reference of the ChildPart, and updates the sparse tree of\n * Disconnectable children accordingly.\n *\n * Note, this method will be patched onto ChildPart instances and called from\n * the core code when parts are moved between different parents.\n */\nfunction reparentDisconnectables(newParent) {\n    if (this._$disconnectableChildren !== undefined) {\n        removeDisconnectableFromParent(this);\n        this._$parent = newParent;\n        addDisconnectableToParent(this);\n    }\n    else {\n        this._$parent = newParent;\n    }\n}\n/**\n * Sets the connected state on any directives contained within the committed\n * value of this part (i.e. within a TemplateInstance or iterable of\n * ChildParts) and runs their `disconnected`/`reconnected`s, as well as within\n * any directives stored on the ChildPart (when `valueOnly` is false).\n *\n * `isClearingValue` should be passed as `true` on a top-level part that is\n * clearing itself, and not as a result of recursively disconnecting directives\n * as part of a `clear` operation higher up the tree. This both ensures that any\n * directive on this ChildPart that produced a value that caused the clear\n * operation is not disconnected, and also serves as a performance optimization\n * to avoid needless bookkeeping when a subtree is going away; when clearing a\n * subtree, only the top-most part need to remove itself from the parent.\n *\n * `fromPartIndex` is passed only in the case of a partial `_clear` running as a\n * result of truncating an iterable.\n *\n * Note, this method will be patched onto ChildPart instances and called from the\n * core code when parts are cleared or the connection state is changed by the\n * user.\n */\nfunction notifyChildPartConnectedChanged(isConnected, isClearingValue = false, fromPartIndex = 0) {\n    const value = this._$committedValue;\n    const children = this._$disconnectableChildren;\n    if (children === undefined || children.size === 0) {\n        return;\n    }\n    if (isClearingValue) {\n        if (Array.isArray(value)) {\n            // Iterable case: Any ChildParts created by the iterable should be\n            // disconnected and removed from this ChildPart's disconnectable\n            // children (starting at `fromPartIndex` in the case of truncation)\n            for (let i = fromPartIndex; i < value.length; i++) {\n                notifyChildrenConnectedChanged(value[i], false);\n                removeDisconnectableFromParent(value[i]);\n            }\n        }\n        else if (value != null) {\n            // TemplateInstance case: If the value has disconnectable children (will\n            // only be in the case that it is a TemplateInstance), we disconnect it\n            // and remove it from this ChildPart's disconnectable children\n            notifyChildrenConnectedChanged(value, false);\n            removeDisconnectableFromParent(value);\n        }\n    }\n    else {\n        notifyChildrenConnectedChanged(this, isConnected);\n    }\n}\n/**\n * Patches disconnection API onto ChildParts.\n */\nconst installDisconnectAPI = (obj) => {\n    var _a, _b;\n    var _c, _d;\n    if (obj.type == PartType.CHILD) {\n        (_a = (_c = obj)._$notifyConnectionChanged) !== null && _a !== void 0 ? _a : (_c._$notifyConnectionChanged = notifyChildPartConnectedChanged);\n        (_b = (_d = obj)._$reparentDisconnectables) !== null && _b !== void 0 ? _b : (_d._$reparentDisconnectables = reparentDisconnectables);\n    }\n};\n/**\n * An abstract `Directive` base class whose `disconnected` method will be\n * called when the part containing the directive is cleared as a result of\n * re-rendering, or when the user calls `part.setConnected(false)` on\n * a part that was previously rendered containing the directive (as happens\n * when e.g. a LitElement disconnects from the DOM).\n *\n * If `part.setConnected(true)` is subsequently called on a\n * containing part, the directive's `reconnected` method will be called prior\n * to its next `update`/`render` callbacks. When implementing `disconnected`,\n * `reconnected` should also be implemented to be compatible with reconnection.\n *\n * Note that updates may occur while the directive is disconnected. As such,\n * directives should generally check the `this.isConnected` flag during\n * render/update to determine whether it is safe to subscribe to resources\n * that may prevent garbage collection.\n */\nexport class AsyncDirective extends Directive {\n    constructor() {\n        super(...arguments);\n        // @internal\n        this._$disconnectableChildren = undefined;\n    }\n    /**\n     * Initialize the part with internal fields\n     * @param part\n     * @param parent\n     * @param attributeIndex\n     */\n    _$initialize(part, parent, attributeIndex) {\n        super._$initialize(part, parent, attributeIndex);\n        addDisconnectableToParent(this);\n        this.isConnected = part._$isConnected;\n    }\n    // This property needs to remain unminified.\n    /**\n     * Called from the core code when a directive is going away from a part (in\n     * which case `shouldRemoveFromParent` should be true), and from the\n     * `setChildrenConnected` helper function when recursively changing the\n     * connection state of a tree (in which case `shouldRemoveFromParent` should\n     * be false).\n     *\n     * @param isConnected\n     * @param isClearingDirective - True when the directive itself is being\n     *     removed; false when the tree is being disconnected\n     * @internal\n     */\n    ['_$notifyDirectiveConnectionChanged'](isConnected, isClearingDirective = true) {\n        var _a, _b;\n        if (isConnected !== this.isConnected) {\n            this.isConnected = isConnected;\n            if (isConnected) {\n                (_a = this.reconnected) === null || _a === void 0 ? void 0 : _a.call(this);\n            }\n            else {\n                (_b = this.disconnected) === null || _b === void 0 ? void 0 : _b.call(this);\n            }\n        }\n        if (isClearingDirective) {\n            notifyChildrenConnectedChanged(this, isConnected);\n            removeDisconnectableFromParent(this);\n        }\n    }\n    /**\n     * Sets the value of the directive's Part outside the normal `update`/`render`\n     * lifecycle of a directive.\n     *\n     * This method should not be called synchronously from a directive's `update`\n     * or `render`.\n     *\n     * @param directive The directive to update\n     * @param value The value to set\n     */\n    setValue(value) {\n        if (isSingleExpression(this.__part)) {\n            this.__part._$setValue(value, this);\n        }\n        else {\n            // this.__attributeIndex will be defined in this case, but\n            // assert it in dev mode\n            if (DEV_MODE && this.__attributeIndex === undefined) {\n                throw new Error(`Expected this.__attributeIndex to be a number`);\n            }\n            const newValues = [...this.__part._$committedValue];\n            newValues[this.__attributeIndex] = value;\n            this.__part._$setValue(newValues, this, 0);\n        }\n    }\n    /**\n     * User callbacks for implementing logic to release any resources/subscriptions\n     * that may have been retained by this directive. Since directives may also be\n     * re-connected, `reconnected` should also be implemented to restore the\n     * working state of the directive prior to the next render.\n     */\n    disconnected() { }\n    reconnected() { }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}