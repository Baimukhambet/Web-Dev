{"ast":null,"code":"/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst legacyCustomElement = (tagName, clazz) => {\n  customElements.define(tagName, clazz);\n  // Cast as any because TS doesn't recognize the return type as being a\n  // subtype of the decorated class when clazz is typed as\n  // `Constructor<HTMLElement>` for some reason.\n  // `Constructor<HTMLElement>` is helpful to make sure the decorator is\n  // applied to elements however.\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return clazz;\n};\nconst standardCustomElement = (tagName, descriptor) => {\n  const {\n    kind,\n    elements\n  } = descriptor;\n  return {\n    kind,\n    elements,\n    // This callback is called once the class is otherwise fully defined\n    finisher(clazz) {\n      customElements.define(tagName, clazz);\n    }\n  };\n};\n/**\n * Class decorator factory that defines the decorated class as a custom element.\n *\n * ```js\n * @customElement('my-element')\n * class MyElement extends LitElement {\n *   render() {\n *     return html``;\n *   }\n * }\n * ```\n * @category Decorator\n * @param tagName The tag name of the custom element to define.\n */\nexport const customElement = tagName => classOrDescriptor => typeof classOrDescriptor === 'function' ? legacyCustomElement(tagName, classOrDescriptor) : standardCustomElement(tagName, classOrDescriptor);","map":{"version":3,"names":["legacyCustomElement","tagName","clazz","customElements","define","standardCustomElement","descriptor","kind","elements","finisher","customElement","classOrDescriptor"],"sources":["/Users/tima/kbtu/4thSemester/web/Lab4/angular/node_modules/@lit/reactive-element/development/decorators/custom-element.js"],"sourcesContent":["/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nconst legacyCustomElement = (tagName, clazz) => {\n    customElements.define(tagName, clazz);\n    // Cast as any because TS doesn't recognize the return type as being a\n    // subtype of the decorated class when clazz is typed as\n    // `Constructor<HTMLElement>` for some reason.\n    // `Constructor<HTMLElement>` is helpful to make sure the decorator is\n    // applied to elements however.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return clazz;\n};\nconst standardCustomElement = (tagName, descriptor) => {\n    const { kind, elements } = descriptor;\n    return {\n        kind,\n        elements,\n        // This callback is called once the class is otherwise fully defined\n        finisher(clazz) {\n            customElements.define(tagName, clazz);\n        },\n    };\n};\n/**\n * Class decorator factory that defines the decorated class as a custom element.\n *\n * ```js\n * @customElement('my-element')\n * class MyElement extends LitElement {\n *   render() {\n *     return html``;\n *   }\n * }\n * ```\n * @category Decorator\n * @param tagName The tag name of the custom element to define.\n */\nexport const customElement = (tagName) => (classOrDescriptor) => typeof classOrDescriptor === 'function'\n    ? legacyCustomElement(tagName, classOrDescriptor)\n    : standardCustomElement(tagName, classOrDescriptor);\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,MAAMA,mBAAmB,GAAG,CAACC,OAAO,EAAEC,KAAK,KAAK;EAC5CC,cAAc,CAACC,MAAM,CAACH,OAAO,EAAEC,KAAK,CAAC;EACrC;EACA;EACA;EACA;EACA;EACA;EACA,OAAOA,KAAK;AAChB,CAAC;AACD,MAAMG,qBAAqB,GAAG,CAACJ,OAAO,EAAEK,UAAU,KAAK;EACnD,MAAM;IAAEC,IAAI;IAAEC;EAAS,CAAC,GAAGF,UAAU;EACrC,OAAO;IACHC,IAAI;IACJC,QAAQ;IACR;IACAC,QAAQ,CAACP,KAAK,EAAE;MACZC,cAAc,CAACC,MAAM,CAACH,OAAO,EAAEC,KAAK,CAAC;IACzC;EACJ,CAAC;AACL,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMQ,aAAa,GAAIT,OAAO,IAAMU,iBAAiB,IAAK,OAAOA,iBAAiB,KAAK,UAAU,GAClGX,mBAAmB,CAACC,OAAO,EAAEU,iBAAiB,CAAC,GAC/CN,qBAAqB,CAACJ,OAAO,EAAEU,iBAAiB,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}