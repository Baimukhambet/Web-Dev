{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { SizeCache } from './shared/SizeCache.js';\nimport { BaseLayout, dim1 } from './shared/BaseLayout.js';\nexport const flow = config => Object.assign({\n  type: FlowLayout\n}, config);\nfunction leadingMargin(direction) {\n  return direction === 'horizontal' ? 'marginLeft' : 'marginTop';\n}\nfunction trailingMargin(direction) {\n  return direction === 'horizontal' ? 'marginRight' : 'marginBottom';\n}\nfunction offset(direction) {\n  return direction === 'horizontal' ? 'xOffset' : 'yOffset';\n}\nfunction collapseMargins(a, b) {\n  const m = [a, b].sort();\n  return m[1] <= 0 ? Math.min(...m) : m[0] >= 0 ? Math.max(...m) : m[0] + m[1];\n}\nclass MetricsCache {\n  constructor() {\n    this._childSizeCache = new SizeCache();\n    this._marginSizeCache = new SizeCache();\n    this._metricsCache = new Map();\n  }\n  update(metrics, direction) {\n    var _a, _b;\n    const marginsToUpdate = new Set();\n    Object.keys(metrics).forEach(key => {\n      const k = Number(key);\n      this._metricsCache.set(k, metrics[k]);\n      this._childSizeCache.set(k, metrics[k][dim1(direction)]);\n      marginsToUpdate.add(k);\n      marginsToUpdate.add(k + 1);\n    });\n    for (const k of marginsToUpdate) {\n      const a = ((_a = this._metricsCache.get(k)) === null || _a === void 0 ? void 0 : _a[leadingMargin(direction)]) || 0;\n      const b = ((_b = this._metricsCache.get(k - 1)) === null || _b === void 0 ? void 0 : _b[trailingMargin(direction)]) || 0;\n      this._marginSizeCache.set(k, collapseMargins(a, b));\n    }\n  }\n  get averageChildSize() {\n    return this._childSizeCache.averageSize;\n  }\n  get totalChildSize() {\n    return this._childSizeCache.totalSize;\n  }\n  get averageMarginSize() {\n    return this._marginSizeCache.averageSize;\n  }\n  get totalMarginSize() {\n    return this._marginSizeCache.totalSize;\n  }\n  getLeadingMarginValue(index, direction) {\n    var _a;\n    return ((_a = this._metricsCache.get(index)) === null || _a === void 0 ? void 0 : _a[leadingMargin(direction)]) || 0;\n  }\n  getChildSize(index) {\n    return this._childSizeCache.getSize(index);\n  }\n  getMarginSize(index) {\n    return this._marginSizeCache.getSize(index);\n  }\n  clear() {\n    this._childSizeCache.clear();\n    this._marginSizeCache.clear();\n    this._metricsCache.clear();\n  }\n}\nexport class FlowLayout extends BaseLayout {\n  constructor() {\n    super(...arguments);\n    /**\n     * Initial estimate of item size\n     */\n    this._itemSize = {\n      width: 100,\n      height: 100\n    };\n    /**\n     * Indices of children mapped to their (position and length) in the scrolling\n     * direction. Used to keep track of children that are in range.\n     */\n    this._physicalItems = new Map();\n    /**\n     * Used in tandem with _physicalItems to track children in range across\n     * reflows.\n     */\n    this._newPhysicalItems = new Map();\n    /**\n     * Width and height of children by their index.\n     */\n    this._metricsCache = new MetricsCache();\n    /**\n     * anchorIdx is the anchor around which we reflow. It is designed to allow\n     * jumping to any point of the scroll size. We choose it once and stick with\n     * it until stable. _first and _last are deduced around it.\n     */\n    this._anchorIdx = null;\n    /**\n     * Position in the scrolling direction of the anchor child.\n     */\n    this._anchorPos = null;\n    /**\n     * Whether all children in range were in range during the previous reflow.\n     */\n    this._stable = true;\n    this._measureChildren = true;\n    this._estimate = true;\n  }\n  // protected _defaultConfig: BaseLayoutConfig = Object.assign({}, super._defaultConfig, {\n  // })\n  // constructor(config: Layout1dConfig) {\n  //   super(config);\n  // }\n  get measureChildren() {\n    return this._measureChildren;\n  }\n  /**\n   * Determine the average size of all children represented in the sizes\n   * argument.\n   */\n  updateItemSizes(sizes) {\n    this._metricsCache.update(sizes, this.direction);\n    // if (this._nMeasured) {\n    // this._updateItemSize();\n    this._scheduleReflow();\n    // }\n  }\n  /**\n   * Set the average item size based on the total length and number of children\n   * in range.\n   */\n  // _updateItemSize() {\n  //   // Keep integer values.\n  //   this._itemSize[this._sizeDim] = this._metricsCache.averageChildSize;\n  // }\n  _getPhysicalItem(idx) {\n    var _a;\n    return (_a = this._newPhysicalItems.get(idx)) !== null && _a !== void 0 ? _a : this._physicalItems.get(idx);\n  }\n  _getSize(idx) {\n    const item = this._getPhysicalItem(idx);\n    return item && this._metricsCache.getChildSize(idx);\n  }\n  _getAverageSize() {\n    return this._metricsCache.averageChildSize || this._itemSize[this._sizeDim];\n  }\n  _estimatePosition(idx) {\n    const c = this._metricsCache;\n    if (this._first === -1 || this._last === -1) {\n      return c.averageMarginSize + idx * (c.averageMarginSize + this._getAverageSize());\n    } else {\n      if (idx < this._first) {\n        const delta = this._first - idx;\n        const refItem = this._getPhysicalItem(this._first);\n        return refItem.pos - (c.getMarginSize(this._first - 1) || c.averageMarginSize) - (delta * c.averageChildSize + (delta - 1) * c.averageMarginSize);\n      } else {\n        const delta = idx - this._last;\n        const refItem = this._getPhysicalItem(this._last);\n        return refItem.pos + (c.getChildSize(this._last) || c.averageChildSize) + (c.getMarginSize(this._last) || c.averageMarginSize) + delta * (c.averageChildSize + c.averageMarginSize);\n      }\n    }\n  }\n  /**\n   * Returns the position in the scrolling direction of the item at idx.\n   * Estimates it if the item at idx is not in the DOM.\n   */\n  _getPosition(idx) {\n    var _a;\n    const item = this._getPhysicalItem(idx);\n    const {\n      averageMarginSize\n    } = this._metricsCache;\n    return idx === 0 ? (_a = this._metricsCache.getMarginSize(0)) !== null && _a !== void 0 ? _a : averageMarginSize : item ? item.pos : this._estimatePosition(idx);\n  }\n  _calculateAnchor(lower, upper) {\n    if (lower <= 0) {\n      return 0;\n    }\n    if (upper > this._scrollSize - this._viewDim1) {\n      return this.items.length - 1;\n    }\n    return Math.max(0, Math.min(this.items.length - 1, Math.floor((lower + upper) / 2 / this._delta)));\n  }\n  _getAnchor(lower, upper) {\n    if (this._physicalItems.size === 0) {\n      return this._calculateAnchor(lower, upper);\n    }\n    if (this._first < 0) {\n      return this._calculateAnchor(lower, upper);\n    }\n    if (this._last < 0) {\n      return this._calculateAnchor(lower, upper);\n    }\n    const firstItem = this._getPhysicalItem(this._first),\n      lastItem = this._getPhysicalItem(this._last),\n      firstMin = firstItem.pos,\n      lastMin = lastItem.pos,\n      lastMax = lastMin + this._metricsCache.getChildSize(this._last);\n    if (lastMax < lower) {\n      // Window is entirely past physical items, calculate new anchor\n      return this._calculateAnchor(lower, upper);\n    }\n    if (firstMin > upper) {\n      // Window is entirely before physical items, calculate new anchor\n      return this._calculateAnchor(lower, upper);\n    }\n    // Window contains a physical item\n    // Find one, starting with the one that was previously first visible\n    let candidateIdx = this._firstVisible - 1;\n    let cMax = -Infinity;\n    while (cMax < lower) {\n      const candidate = this._getPhysicalItem(++candidateIdx);\n      cMax = candidate.pos + this._metricsCache.getChildSize(candidateIdx);\n    }\n    return candidateIdx;\n  }\n  /**\n   * Updates _first and _last based on items that should be in the current\n   * viewed range.\n   */\n  _getActiveItems() {\n    if (this._viewDim1 === 0 || this.items.length === 0) {\n      this._clearItems();\n    } else {\n      this._getItems();\n    }\n  }\n  /**\n   * Sets the range to empty.\n   */\n  _clearItems() {\n    this._first = -1;\n    this._last = -1;\n    this._physicalMin = 0;\n    this._physicalMax = 0;\n    const items = this._newPhysicalItems;\n    this._newPhysicalItems = this._physicalItems;\n    this._newPhysicalItems.clear();\n    this._physicalItems = items;\n    this._stable = true;\n  }\n  /*\n   * Updates _first and _last based on items that should be in the given range.\n   */\n  _getItems() {\n    var _a, _b;\n    const items = this._newPhysicalItems;\n    this._stable = true;\n    let lower, upper;\n    // The anchorIdx is the anchor around which we reflow. It is designed to\n    // allow jumping to any point of the scroll size. We choose it once and\n    // stick with it until stable. first and last are deduced around it.\n    // If we have a pinned item, we anchor on it\n    if (this.pin !== null) {\n      const {\n        index\n      } = this.pin;\n      this._anchorIdx = index;\n      this._anchorPos = this._getPosition(index);\n    }\n    // Determine the lower and upper bounds of the region to be\n    // rendered, relative to the viewport\n    lower = this._scrollPosition - this._overhang; //leadingOverhang;\n    upper = this._scrollPosition + this._viewDim1 + this._overhang; // trailingOverhang;\n    if (upper < 0 || lower > this._scrollSize) {\n      this._clearItems();\n      return;\n    }\n    // If we are scrolling to a specific index or if we are doing another\n    // pass to stabilize a previously started reflow, we will already\n    // have an anchor. If not, establish an anchor now.\n    if (this._anchorIdx === null || this._anchorPos === null) {\n      this._anchorIdx = this._getAnchor(lower, upper);\n      this._anchorPos = this._getPosition(this._anchorIdx);\n    }\n    let anchorSize = this._getSize(this._anchorIdx);\n    if (anchorSize === undefined) {\n      this._stable = false;\n      anchorSize = this._getAverageSize();\n    }\n    const anchorLeadingMargin = (_a = this._metricsCache.getMarginSize(this._anchorIdx)) !== null && _a !== void 0 ? _a : this._metricsCache.averageMarginSize;\n    const anchorTrailingMargin = (_b = this._metricsCache.getMarginSize(this._anchorIdx + 1)) !== null && _b !== void 0 ? _b : this._metricsCache.averageMarginSize;\n    if (this._anchorIdx === 0) {\n      this._anchorPos = anchorLeadingMargin;\n    }\n    if (this._anchorIdx === this.items.length - 1) {\n      this._anchorPos = this._scrollSize - anchorTrailingMargin - anchorSize;\n    }\n    // Anchor might be outside bounds, so prefer correcting the error and keep\n    // that anchorIdx.\n    let anchorErr = 0;\n    if (this._anchorPos + anchorSize + anchorTrailingMargin < lower) {\n      anchorErr = lower - (this._anchorPos + anchorSize + anchorTrailingMargin);\n    }\n    if (this._anchorPos - anchorLeadingMargin > upper) {\n      anchorErr = upper - (this._anchorPos - anchorLeadingMargin);\n    }\n    if (anchorErr) {\n      this._scrollPosition -= anchorErr;\n      lower -= anchorErr;\n      upper -= anchorErr;\n      this._scrollError += anchorErr;\n    }\n    items.set(this._anchorIdx, {\n      pos: this._anchorPos,\n      size: anchorSize\n    });\n    this._first = this._last = this._anchorIdx;\n    this._physicalMin = this._anchorPos - anchorLeadingMargin;\n    this._physicalMax = this._anchorPos + anchorSize + anchorTrailingMargin;\n    while (this._physicalMin > lower && this._first > 0) {\n      let size = this._getSize(--this._first);\n      if (size === undefined) {\n        this._stable = false;\n        size = this._getAverageSize();\n      }\n      let margin = this._metricsCache.getMarginSize(this._first);\n      if (margin === undefined) {\n        this._stable = false;\n        margin = this._metricsCache.averageMarginSize;\n      }\n      this._physicalMin -= size;\n      const pos = this._physicalMin;\n      items.set(this._first, {\n        pos,\n        size\n      });\n      this._physicalMin -= margin;\n      if (this._stable === false && this._estimate === false) {\n        break;\n      }\n    }\n    while (this._physicalMax < upper && this._last < this.items.length - 1) {\n      let size = this._getSize(++this._last);\n      if (size === undefined) {\n        this._stable = false;\n        size = this._getAverageSize();\n      }\n      let margin = this._metricsCache.getMarginSize(this._last);\n      if (margin === undefined) {\n        this._stable = false;\n        margin = this._metricsCache.averageMarginSize;\n      }\n      const pos = this._physicalMax;\n      items.set(this._last, {\n        pos,\n        size\n      });\n      this._physicalMax += size + margin;\n      if (!this._stable && !this._estimate) {\n        break;\n      }\n    }\n    // This handles the cases where we were relying on estimated sizes.\n    const extentErr = this._calculateError();\n    if (extentErr) {\n      this._physicalMin -= extentErr;\n      this._physicalMax -= extentErr;\n      this._anchorPos -= extentErr;\n      this._scrollPosition -= extentErr;\n      items.forEach(item => item.pos -= extentErr);\n      this._scrollError += extentErr;\n    }\n    if (this._stable) {\n      this._newPhysicalItems = this._physicalItems;\n      this._newPhysicalItems.clear();\n      this._physicalItems = items;\n    }\n  }\n  _calculateError() {\n    if (this._first === 0) {\n      return this._physicalMin;\n    } else if (this._physicalMin <= 0) {\n      return this._physicalMin - this._first * this._delta;\n    } else if (this._last === this.items.length - 1) {\n      return this._physicalMax - this._scrollSize;\n    } else if (this._physicalMax >= this._scrollSize) {\n      return this._physicalMax - this._scrollSize + (this.items.length - 1 - this._last) * this._delta;\n    }\n    return 0;\n  }\n  // TODO: Can this be made to inherit from base, with proper hooks?\n  _reflow() {\n    const {\n      _first,\n      _last,\n      _scrollSize,\n      _firstVisible,\n      _lastVisible\n    } = this;\n    this._updateScrollSize();\n    this._setPositionFromPin();\n    this._getActiveItems();\n    this._updateVisibleIndices();\n    if (this._scrollSize !== _scrollSize) {\n      this._emitScrollSize();\n    }\n    if (this._first !== _first || this._last !== _last || this._firstVisible !== _firstVisible || this._lastVisible !== _lastVisible) {\n      this._emitRange();\n    }\n    if (!(this._first === -1 && this._last === -1)) {\n      this._emitChildPositions();\n    }\n    if (this._scrollError !== 0) {\n      this._emitScrollError();\n    }\n    if (this._first === -1 && this._last == -1 || this._first === _first && this._last === _last) {\n      this._resetReflowState();\n    }\n  }\n  _resetReflowState() {\n    this._anchorIdx = null;\n    this._anchorPos = null;\n    this._stable = true;\n  }\n  _updateScrollSize() {\n    const {\n      averageMarginSize\n    } = this._metricsCache;\n    this._scrollSize = Math.max(1, this.items.length * (averageMarginSize + this._getAverageSize()) + averageMarginSize);\n  }\n  /**\n   * Returns the average size (precise or estimated) of an item in the scrolling direction,\n   * including any surrounding space.\n   */\n  get _delta() {\n    const {\n      averageMarginSize\n    } = this._metricsCache;\n    return this._getAverageSize() + averageMarginSize;\n  }\n  /**\n   * Returns the top and left positioning of the item at idx.\n   */\n  _getItemPosition(idx) {\n    var _a;\n    return {\n      [this._positionDim]: this._getPosition(idx),\n      [this._secondaryPositionDim]: 0,\n      [offset(this.direction)]: -((_a = this._metricsCache.getLeadingMarginValue(idx, this.direction)) !== null && _a !== void 0 ? _a : this._metricsCache.averageMarginSize)\n    };\n  }\n  /**\n   * Returns the height and width of the item at idx.\n   */\n  _getItemSize(idx) {\n    return {\n      [this._sizeDim]: this._getSize(idx) || this._getAverageSize(),\n      [this._secondarySizeDim]: this._itemSize[this._secondarySizeDim]\n    };\n  }\n  _viewDim2Changed() {\n    this._metricsCache.clear();\n    this._scheduleReflow();\n  }\n}","map":{"version":3,"names":["SizeCache","BaseLayout","dim1","flow","config","Object","assign","type","FlowLayout","leadingMargin","direction","trailingMargin","offset","collapseMargins","a","b","m","sort","Math","min","max","MetricsCache","constructor","_childSizeCache","_marginSizeCache","_metricsCache","Map","update","metrics","_a","_b","marginsToUpdate","Set","keys","forEach","key","k","Number","set","add","get","averageChildSize","averageSize","totalChildSize","totalSize","averageMarginSize","totalMarginSize","getLeadingMarginValue","index","getChildSize","getSize","getMarginSize","clear","arguments","_itemSize","width","height","_physicalItems","_newPhysicalItems","_anchorIdx","_anchorPos","_stable","_measureChildren","_estimate","measureChildren","updateItemSizes","sizes","_scheduleReflow","_getPhysicalItem","idx","_getSize","item","_getAverageSize","_sizeDim","_estimatePosition","c","_first","_last","delta","refItem","pos","_getPosition","_calculateAnchor","lower","upper","_scrollSize","_viewDim1","items","length","floor","_delta","_getAnchor","size","firstItem","lastItem","firstMin","lastMin","lastMax","candidateIdx","_firstVisible","cMax","Infinity","candidate","_getActiveItems","_clearItems","_getItems","_physicalMin","_physicalMax","pin","_scrollPosition","_overhang","anchorSize","undefined","anchorLeadingMargin","anchorTrailingMargin","anchorErr","_scrollError","margin","extentErr","_calculateError","_reflow","_lastVisible","_updateScrollSize","_setPositionFromPin","_updateVisibleIndices","_emitScrollSize","_emitRange","_emitChildPositions","_emitScrollError","_resetReflowState","_getItemPosition","_positionDim","_secondaryPositionDim","_getItemSize","_secondarySizeDim","_viewDim2Changed"],"sources":["/Users/tima/kbtu/4thSemester/web/Lab4/angular/node_modules/@lit-labs/virtualizer/layouts/flow.js"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { SizeCache } from './shared/SizeCache.js';\nimport { BaseLayout, dim1 } from './shared/BaseLayout.js';\nexport const flow = (config) => Object.assign({\n    type: FlowLayout,\n}, config);\nfunction leadingMargin(direction) {\n    return direction === 'horizontal' ? 'marginLeft' : 'marginTop';\n}\nfunction trailingMargin(direction) {\n    return direction === 'horizontal' ? 'marginRight' : 'marginBottom';\n}\nfunction offset(direction) {\n    return direction === 'horizontal' ? 'xOffset' : 'yOffset';\n}\nfunction collapseMargins(a, b) {\n    const m = [a, b].sort();\n    return m[1] <= 0 ? Math.min(...m) : m[0] >= 0 ? Math.max(...m) : m[0] + m[1];\n}\nclass MetricsCache {\n    constructor() {\n        this._childSizeCache = new SizeCache();\n        this._marginSizeCache = new SizeCache();\n        this._metricsCache = new Map();\n    }\n    update(metrics, direction) {\n        var _a, _b;\n        const marginsToUpdate = new Set();\n        Object.keys(metrics).forEach((key) => {\n            const k = Number(key);\n            this._metricsCache.set(k, metrics[k]);\n            this._childSizeCache.set(k, metrics[k][dim1(direction)]);\n            marginsToUpdate.add(k);\n            marginsToUpdate.add(k + 1);\n        });\n        for (const k of marginsToUpdate) {\n            const a = ((_a = this._metricsCache.get(k)) === null || _a === void 0 ? void 0 : _a[leadingMargin(direction)]) || 0;\n            const b = ((_b = this._metricsCache.get(k - 1)) === null || _b === void 0 ? void 0 : _b[trailingMargin(direction)]) || 0;\n            this._marginSizeCache.set(k, collapseMargins(a, b));\n        }\n    }\n    get averageChildSize() {\n        return this._childSizeCache.averageSize;\n    }\n    get totalChildSize() {\n        return this._childSizeCache.totalSize;\n    }\n    get averageMarginSize() {\n        return this._marginSizeCache.averageSize;\n    }\n    get totalMarginSize() {\n        return this._marginSizeCache.totalSize;\n    }\n    getLeadingMarginValue(index, direction) {\n        var _a;\n        return ((_a = this._metricsCache.get(index)) === null || _a === void 0 ? void 0 : _a[leadingMargin(direction)]) || 0;\n    }\n    getChildSize(index) {\n        return this._childSizeCache.getSize(index);\n    }\n    getMarginSize(index) {\n        return this._marginSizeCache.getSize(index);\n    }\n    clear() {\n        this._childSizeCache.clear();\n        this._marginSizeCache.clear();\n        this._metricsCache.clear();\n    }\n}\nexport class FlowLayout extends BaseLayout {\n    constructor() {\n        super(...arguments);\n        /**\n         * Initial estimate of item size\n         */\n        this._itemSize = { width: 100, height: 100 };\n        /**\n         * Indices of children mapped to their (position and length) in the scrolling\n         * direction. Used to keep track of children that are in range.\n         */\n        this._physicalItems = new Map();\n        /**\n         * Used in tandem with _physicalItems to track children in range across\n         * reflows.\n         */\n        this._newPhysicalItems = new Map();\n        /**\n         * Width and height of children by their index.\n         */\n        this._metricsCache = new MetricsCache();\n        /**\n         * anchorIdx is the anchor around which we reflow. It is designed to allow\n         * jumping to any point of the scroll size. We choose it once and stick with\n         * it until stable. _first and _last are deduced around it.\n         */\n        this._anchorIdx = null;\n        /**\n         * Position in the scrolling direction of the anchor child.\n         */\n        this._anchorPos = null;\n        /**\n         * Whether all children in range were in range during the previous reflow.\n         */\n        this._stable = true;\n        this._measureChildren = true;\n        this._estimate = true;\n    }\n    // protected _defaultConfig: BaseLayoutConfig = Object.assign({}, super._defaultConfig, {\n    // })\n    // constructor(config: Layout1dConfig) {\n    //   super(config);\n    // }\n    get measureChildren() {\n        return this._measureChildren;\n    }\n    /**\n     * Determine the average size of all children represented in the sizes\n     * argument.\n     */\n    updateItemSizes(sizes) {\n        this._metricsCache.update(sizes, this.direction);\n        // if (this._nMeasured) {\n        // this._updateItemSize();\n        this._scheduleReflow();\n        // }\n    }\n    /**\n     * Set the average item size based on the total length and number of children\n     * in range.\n     */\n    // _updateItemSize() {\n    //   // Keep integer values.\n    //   this._itemSize[this._sizeDim] = this._metricsCache.averageChildSize;\n    // }\n    _getPhysicalItem(idx) {\n        var _a;\n        return (_a = this._newPhysicalItems.get(idx)) !== null && _a !== void 0 ? _a : this._physicalItems.get(idx);\n    }\n    _getSize(idx) {\n        const item = this._getPhysicalItem(idx);\n        return item && this._metricsCache.getChildSize(idx);\n    }\n    _getAverageSize() {\n        return this._metricsCache.averageChildSize || this._itemSize[this._sizeDim];\n    }\n    _estimatePosition(idx) {\n        const c = this._metricsCache;\n        if (this._first === -1 || this._last === -1) {\n            return (c.averageMarginSize +\n                idx * (c.averageMarginSize + this._getAverageSize()));\n        }\n        else {\n            if (idx < this._first) {\n                const delta = this._first - idx;\n                const refItem = this._getPhysicalItem(this._first);\n                return (refItem.pos -\n                    (c.getMarginSize(this._first - 1) || c.averageMarginSize) -\n                    (delta * c.averageChildSize + (delta - 1) * c.averageMarginSize));\n            }\n            else {\n                const delta = idx - this._last;\n                const refItem = this._getPhysicalItem(this._last);\n                return (refItem.pos +\n                    (c.getChildSize(this._last) || c.averageChildSize) +\n                    (c.getMarginSize(this._last) || c.averageMarginSize) +\n                    delta * (c.averageChildSize + c.averageMarginSize));\n            }\n        }\n    }\n    /**\n     * Returns the position in the scrolling direction of the item at idx.\n     * Estimates it if the item at idx is not in the DOM.\n     */\n    _getPosition(idx) {\n        var _a;\n        const item = this._getPhysicalItem(idx);\n        const { averageMarginSize } = this._metricsCache;\n        return idx === 0\n            ? (_a = this._metricsCache.getMarginSize(0)) !== null && _a !== void 0 ? _a : averageMarginSize\n            : item\n                ? item.pos\n                : this._estimatePosition(idx);\n    }\n    _calculateAnchor(lower, upper) {\n        if (lower <= 0) {\n            return 0;\n        }\n        if (upper > this._scrollSize - this._viewDim1) {\n            return this.items.length - 1;\n        }\n        return Math.max(0, Math.min(this.items.length - 1, Math.floor((lower + upper) / 2 / this._delta)));\n    }\n    _getAnchor(lower, upper) {\n        if (this._physicalItems.size === 0) {\n            return this._calculateAnchor(lower, upper);\n        }\n        if (this._first < 0) {\n            return this._calculateAnchor(lower, upper);\n        }\n        if (this._last < 0) {\n            return this._calculateAnchor(lower, upper);\n        }\n        const firstItem = this._getPhysicalItem(this._first), lastItem = this._getPhysicalItem(this._last), firstMin = firstItem.pos, lastMin = lastItem.pos, lastMax = lastMin + this._metricsCache.getChildSize(this._last);\n        if (lastMax < lower) {\n            // Window is entirely past physical items, calculate new anchor\n            return this._calculateAnchor(lower, upper);\n        }\n        if (firstMin > upper) {\n            // Window is entirely before physical items, calculate new anchor\n            return this._calculateAnchor(lower, upper);\n        }\n        // Window contains a physical item\n        // Find one, starting with the one that was previously first visible\n        let candidateIdx = this._firstVisible - 1;\n        let cMax = -Infinity;\n        while (cMax < lower) {\n            const candidate = this._getPhysicalItem(++candidateIdx);\n            cMax = candidate.pos + this._metricsCache.getChildSize(candidateIdx);\n        }\n        return candidateIdx;\n    }\n    /**\n     * Updates _first and _last based on items that should be in the current\n     * viewed range.\n     */\n    _getActiveItems() {\n        if (this._viewDim1 === 0 || this.items.length === 0) {\n            this._clearItems();\n        }\n        else {\n            this._getItems();\n        }\n    }\n    /**\n     * Sets the range to empty.\n     */\n    _clearItems() {\n        this._first = -1;\n        this._last = -1;\n        this._physicalMin = 0;\n        this._physicalMax = 0;\n        const items = this._newPhysicalItems;\n        this._newPhysicalItems = this._physicalItems;\n        this._newPhysicalItems.clear();\n        this._physicalItems = items;\n        this._stable = true;\n    }\n    /*\n     * Updates _first and _last based on items that should be in the given range.\n     */\n    _getItems() {\n        var _a, _b;\n        const items = this._newPhysicalItems;\n        this._stable = true;\n        let lower, upper;\n        // The anchorIdx is the anchor around which we reflow. It is designed to\n        // allow jumping to any point of the scroll size. We choose it once and\n        // stick with it until stable. first and last are deduced around it.\n        // If we have a pinned item, we anchor on it\n        if (this.pin !== null) {\n            const { index } = this.pin;\n            this._anchorIdx = index;\n            this._anchorPos = this._getPosition(index);\n        }\n        // Determine the lower and upper bounds of the region to be\n        // rendered, relative to the viewport\n        lower = this._scrollPosition - this._overhang; //leadingOverhang;\n        upper = this._scrollPosition + this._viewDim1 + this._overhang; // trailingOverhang;\n        if (upper < 0 || lower > this._scrollSize) {\n            this._clearItems();\n            return;\n        }\n        // If we are scrolling to a specific index or if we are doing another\n        // pass to stabilize a previously started reflow, we will already\n        // have an anchor. If not, establish an anchor now.\n        if (this._anchorIdx === null || this._anchorPos === null) {\n            this._anchorIdx = this._getAnchor(lower, upper);\n            this._anchorPos = this._getPosition(this._anchorIdx);\n        }\n        let anchorSize = this._getSize(this._anchorIdx);\n        if (anchorSize === undefined) {\n            this._stable = false;\n            anchorSize = this._getAverageSize();\n        }\n        const anchorLeadingMargin = (_a = this._metricsCache.getMarginSize(this._anchorIdx)) !== null && _a !== void 0 ? _a : this._metricsCache.averageMarginSize;\n        const anchorTrailingMargin = (_b = this._metricsCache.getMarginSize(this._anchorIdx + 1)) !== null && _b !== void 0 ? _b : this._metricsCache.averageMarginSize;\n        if (this._anchorIdx === 0) {\n            this._anchorPos = anchorLeadingMargin;\n        }\n        if (this._anchorIdx === this.items.length - 1) {\n            this._anchorPos = this._scrollSize - anchorTrailingMargin - anchorSize;\n        }\n        // Anchor might be outside bounds, so prefer correcting the error and keep\n        // that anchorIdx.\n        let anchorErr = 0;\n        if (this._anchorPos + anchorSize + anchorTrailingMargin < lower) {\n            anchorErr = lower - (this._anchorPos + anchorSize + anchorTrailingMargin);\n        }\n        if (this._anchorPos - anchorLeadingMargin > upper) {\n            anchorErr = upper - (this._anchorPos - anchorLeadingMargin);\n        }\n        if (anchorErr) {\n            this._scrollPosition -= anchorErr;\n            lower -= anchorErr;\n            upper -= anchorErr;\n            this._scrollError += anchorErr;\n        }\n        items.set(this._anchorIdx, { pos: this._anchorPos, size: anchorSize });\n        this._first = this._last = this._anchorIdx;\n        this._physicalMin = this._anchorPos - anchorLeadingMargin;\n        this._physicalMax = this._anchorPos + anchorSize + anchorTrailingMargin;\n        while (this._physicalMin > lower && this._first > 0) {\n            let size = this._getSize(--this._first);\n            if (size === undefined) {\n                this._stable = false;\n                size = this._getAverageSize();\n            }\n            let margin = this._metricsCache.getMarginSize(this._first);\n            if (margin === undefined) {\n                this._stable = false;\n                margin = this._metricsCache.averageMarginSize;\n            }\n            this._physicalMin -= size;\n            const pos = this._physicalMin;\n            items.set(this._first, { pos, size });\n            this._physicalMin -= margin;\n            if (this._stable === false && this._estimate === false) {\n                break;\n            }\n        }\n        while (this._physicalMax < upper && this._last < this.items.length - 1) {\n            let size = this._getSize(++this._last);\n            if (size === undefined) {\n                this._stable = false;\n                size = this._getAverageSize();\n            }\n            let margin = this._metricsCache.getMarginSize(this._last);\n            if (margin === undefined) {\n                this._stable = false;\n                margin = this._metricsCache.averageMarginSize;\n            }\n            const pos = this._physicalMax;\n            items.set(this._last, { pos, size });\n            this._physicalMax += size + margin;\n            if (!this._stable && !this._estimate) {\n                break;\n            }\n        }\n        // This handles the cases where we were relying on estimated sizes.\n        const extentErr = this._calculateError();\n        if (extentErr) {\n            this._physicalMin -= extentErr;\n            this._physicalMax -= extentErr;\n            this._anchorPos -= extentErr;\n            this._scrollPosition -= extentErr;\n            items.forEach((item) => (item.pos -= extentErr));\n            this._scrollError += extentErr;\n        }\n        if (this._stable) {\n            this._newPhysicalItems = this._physicalItems;\n            this._newPhysicalItems.clear();\n            this._physicalItems = items;\n        }\n    }\n    _calculateError() {\n        if (this._first === 0) {\n            return this._physicalMin;\n        }\n        else if (this._physicalMin <= 0) {\n            return this._physicalMin - this._first * this._delta;\n        }\n        else if (this._last === this.items.length - 1) {\n            return this._physicalMax - this._scrollSize;\n        }\n        else if (this._physicalMax >= this._scrollSize) {\n            return (this._physicalMax -\n                this._scrollSize +\n                (this.items.length - 1 - this._last) * this._delta);\n        }\n        return 0;\n    }\n    // TODO: Can this be made to inherit from base, with proper hooks?\n    _reflow() {\n        const { _first, _last, _scrollSize, _firstVisible, _lastVisible } = this;\n        this._updateScrollSize();\n        this._setPositionFromPin();\n        this._getActiveItems();\n        this._updateVisibleIndices();\n        if (this._scrollSize !== _scrollSize) {\n            this._emitScrollSize();\n        }\n        if (this._first !== _first ||\n            this._last !== _last ||\n            this._firstVisible !== _firstVisible ||\n            this._lastVisible !== _lastVisible) {\n            this._emitRange();\n        }\n        if (!(this._first === -1 && this._last === -1)) {\n            this._emitChildPositions();\n        }\n        if (this._scrollError !== 0) {\n            this._emitScrollError();\n        }\n        if ((this._first === -1 && this._last == -1) ||\n            (this._first === _first && this._last === _last)) {\n            this._resetReflowState();\n        }\n    }\n    _resetReflowState() {\n        this._anchorIdx = null;\n        this._anchorPos = null;\n        this._stable = true;\n    }\n    _updateScrollSize() {\n        const { averageMarginSize } = this._metricsCache;\n        this._scrollSize = Math.max(1, this.items.length * (averageMarginSize + this._getAverageSize()) +\n            averageMarginSize);\n    }\n    /**\n     * Returns the average size (precise or estimated) of an item in the scrolling direction,\n     * including any surrounding space.\n     */\n    get _delta() {\n        const { averageMarginSize } = this._metricsCache;\n        return this._getAverageSize() + averageMarginSize;\n    }\n    /**\n     * Returns the top and left positioning of the item at idx.\n     */\n    _getItemPosition(idx) {\n        var _a;\n        return {\n            [this._positionDim]: this._getPosition(idx),\n            [this._secondaryPositionDim]: 0,\n            [offset(this.direction)]: -((_a = this._metricsCache.getLeadingMarginValue(idx, this.direction)) !== null && _a !== void 0 ? _a : this._metricsCache.averageMarginSize),\n        };\n    }\n    /**\n     * Returns the height and width of the item at idx.\n     */\n    _getItemSize(idx) {\n        return {\n            [this._sizeDim]: this._getSize(idx) || this._getAverageSize(),\n            [this._secondarySizeDim]: this._itemSize[this._secondarySizeDim],\n        };\n    }\n    _viewDim2Changed() {\n        this._metricsCache.clear();\n        this._scheduleReflow();\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}