{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { noChange } from '../lit-html.js';\nimport { directive, Directive, PartType } from '../directive.js';\nclass ClassMapDirective extends Directive {\n  constructor(partInfo) {\n    var _a;\n    super(partInfo);\n    if (partInfo.type !== PartType.ATTRIBUTE || partInfo.name !== 'class' || ((_a = partInfo.strings) === null || _a === void 0 ? void 0 : _a.length) > 2) {\n      throw new Error('`classMap()` can only be used in the `class` attribute ' + 'and must be the only part in the attribute.');\n    }\n  }\n  render(classInfo) {\n    // Add spaces to ensure separation from static classes\n    return ' ' + Object.keys(classInfo).filter(key => classInfo[key]).join(' ') + ' ';\n  }\n  update(part, [classInfo]) {\n    var _a, _b;\n    // Remember dynamic classes on the first render\n    if (this._previousClasses === undefined) {\n      this._previousClasses = new Set();\n      if (part.strings !== undefined) {\n        this._staticClasses = new Set(part.strings.join(' ').split(/\\s/).filter(s => s !== ''));\n      }\n      for (const name in classInfo) {\n        if (classInfo[name] && !((_a = this._staticClasses) === null || _a === void 0 ? void 0 : _a.has(name))) {\n          this._previousClasses.add(name);\n        }\n      }\n      return this.render(classInfo);\n    }\n    const classList = part.element.classList;\n    // Remove old classes that no longer apply\n    // We use forEach() instead of for-of so that we don't require down-level\n    // iteration.\n    this._previousClasses.forEach(name => {\n      if (!(name in classInfo)) {\n        classList.remove(name);\n        this._previousClasses.delete(name);\n      }\n    });\n    // Add or remove classes based on their classMap value\n    for (const name in classInfo) {\n      // We explicitly want a loose truthy check of `value` because it seems\n      // more convenient that '' and 0 are skipped.\n      const value = !!classInfo[name];\n      if (value !== this._previousClasses.has(name) && !((_b = this._staticClasses) === null || _b === void 0 ? void 0 : _b.has(name))) {\n        if (value) {\n          classList.add(name);\n          this._previousClasses.add(name);\n        } else {\n          classList.remove(name);\n          this._previousClasses.delete(name);\n        }\n      }\n    }\n    return noChange;\n  }\n}\n/**\n * A directive that applies dynamic CSS classes.\n *\n * This must be used in the `class` attribute and must be the only part used in\n * the attribute. It takes each property in the `classInfo` argument and adds\n * the property name to the element's `classList` if the property value is\n * truthy; if the property value is falsey, the property name is removed from\n * the element's `class`.\n *\n * For example `{foo: bar}` applies the class `foo` if the value of `bar` is\n * truthy.\n *\n * @param classInfo\n */\nexport const classMap = directive(ClassMapDirective);","map":{"version":3,"names":["noChange","directive","Directive","PartType","ClassMapDirective","constructor","partInfo","_a","type","ATTRIBUTE","name","strings","length","Error","render","classInfo","Object","keys","filter","key","join","update","part","_b","_previousClasses","undefined","Set","_staticClasses","split","s","has","add","classList","element","forEach","remove","delete","value","classMap"],"sources":["/Users/tima/kbtu/4thSemester/web/Lab4/angular/node_modules/lit-html/development/directives/class-map.js"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { noChange } from '../lit-html.js';\nimport { directive, Directive, PartType, } from '../directive.js';\nclass ClassMapDirective extends Directive {\n    constructor(partInfo) {\n        var _a;\n        super(partInfo);\n        if (partInfo.type !== PartType.ATTRIBUTE ||\n            partInfo.name !== 'class' ||\n            ((_a = partInfo.strings) === null || _a === void 0 ? void 0 : _a.length) > 2) {\n            throw new Error('`classMap()` can only be used in the `class` attribute ' +\n                'and must be the only part in the attribute.');\n        }\n    }\n    render(classInfo) {\n        // Add spaces to ensure separation from static classes\n        return (' ' +\n            Object.keys(classInfo)\n                .filter((key) => classInfo[key])\n                .join(' ') +\n            ' ');\n    }\n    update(part, [classInfo]) {\n        var _a, _b;\n        // Remember dynamic classes on the first render\n        if (this._previousClasses === undefined) {\n            this._previousClasses = new Set();\n            if (part.strings !== undefined) {\n                this._staticClasses = new Set(part.strings\n                    .join(' ')\n                    .split(/\\s/)\n                    .filter((s) => s !== ''));\n            }\n            for (const name in classInfo) {\n                if (classInfo[name] && !((_a = this._staticClasses) === null || _a === void 0 ? void 0 : _a.has(name))) {\n                    this._previousClasses.add(name);\n                }\n            }\n            return this.render(classInfo);\n        }\n        const classList = part.element.classList;\n        // Remove old classes that no longer apply\n        // We use forEach() instead of for-of so that we don't require down-level\n        // iteration.\n        this._previousClasses.forEach((name) => {\n            if (!(name in classInfo)) {\n                classList.remove(name);\n                this._previousClasses.delete(name);\n            }\n        });\n        // Add or remove classes based on their classMap value\n        for (const name in classInfo) {\n            // We explicitly want a loose truthy check of `value` because it seems\n            // more convenient that '' and 0 are skipped.\n            const value = !!classInfo[name];\n            if (value !== this._previousClasses.has(name) &&\n                !((_b = this._staticClasses) === null || _b === void 0 ? void 0 : _b.has(name))) {\n                if (value) {\n                    classList.add(name);\n                    this._previousClasses.add(name);\n                }\n                else {\n                    classList.remove(name);\n                    this._previousClasses.delete(name);\n                }\n            }\n        }\n        return noChange;\n    }\n}\n/**\n * A directive that applies dynamic CSS classes.\n *\n * This must be used in the `class` attribute and must be the only part used in\n * the attribute. It takes each property in the `classInfo` argument and adds\n * the property name to the element's `classList` if the property value is\n * truthy; if the property value is falsey, the property name is removed from\n * the element's `class`.\n *\n * For example `{foo: bar}` applies the class `foo` if the value of `bar` is\n * truthy.\n *\n * @param classInfo\n */\nexport const classMap = directive(ClassMapDirective);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}