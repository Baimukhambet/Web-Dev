{"ast":null,"code":"import _asyncToGenerator from \"/Users/tima/kbtu/4thSemester/web/Lab4/angular/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport getResizeObserver from './polyfillLoaders/ResizeObserver.js';\nimport { RangeChangedEvent, VisibilityChangedEvent, UnpinnedEvent } from './events.js';\nimport { ScrollerController } from './ScrollerController.js';\nexport const virtualizerRef = Symbol('virtualizerRef');\nconst SIZER_ATTRIBUTE = 'virtualizer-sizer';\nlet DefaultLayoutConstructor;\n/**\n * Provides virtual scrolling boilerplate.\n *\n * Extensions of this class must set hostElement and layout.\n *\n * Extensions of this class must also override VirtualRepeater's DOM\n * manipulation methods.\n */\nexport class Virtualizer {\n  constructor(config) {\n    this._benchmarkStart = null;\n    this._layout = null;\n    this._clippingAncestors = [];\n    /**\n     * Layout provides these values, we set them on _render().\n     * TODO @straversi: Can we find an XOR type, usable for the key here?\n     */\n    this._scrollSize = null;\n    /**\n     * Difference between scroll target's current and required scroll offsets.\n     * Provided by layout.\n     */\n    this._scrollError = null;\n    /**\n     * A list of the positions (top, left) of the children in the current range.\n     */\n    this._childrenPos = null;\n    // TODO: (graynorton): type\n    this._childMeasurements = null;\n    this._toBeMeasured = new Map();\n    this._rangeChanged = true;\n    this._itemsChanged = true;\n    this._visibilityChanged = true;\n    this._scrollerController = null;\n    this._isScroller = false;\n    this._sizer = null;\n    /**\n     * Resize observer attached to hostElement.\n     */\n    this._hostElementRO = null;\n    /**\n     * Resize observer attached to children.\n     */\n    this._childrenRO = null;\n    this._mutationObserver = null;\n    this._scrollEventListeners = [];\n    this._scrollEventListenerOptions = {\n      passive: true\n    };\n    // TODO (graynorton): Rethink, per longer comment below\n    this._loadListener = this._childLoaded.bind(this);\n    /**\n     * Index of element to scroll into view, plus scroll\n     * behavior options, as imperatively specified via\n     * `element(index).scrollIntoView()`\n     */\n    this._scrollIntoViewTarget = null;\n    this._updateScrollIntoViewCoordinates = null;\n    /**\n     * Items to render. Set by items.\n     */\n    this._items = [];\n    /**\n     * Index of the first child in the range, not necessarily the first visible child.\n     * TODO @straversi: Consider renaming these.\n     */\n    this._first = -1;\n    /**\n     * Index of the last child in the range.\n     */\n    this._last = -1;\n    /**\n     * Index of the first item intersecting the viewport.\n     */\n    this._firstVisible = -1;\n    /**\n     * Index of the last item intersecting the viewport.\n     */\n    this._lastVisible = -1;\n    this._scheduled = new WeakSet();\n    /**\n     * Invoked at the end of each render cycle: children in the range are\n     * measured, and their dimensions passed to this callback. Use it to layout\n     * children as needed.\n     */\n    this._measureCallback = null;\n    this._measureChildOverride = null;\n    /**\n     * State for `layoutComplete` promise\n     */\n    this._layoutCompletePromise = null;\n    this._layoutCompleteResolver = null;\n    this._layoutCompleteRejecter = null;\n    this._pendingLayoutComplete = null;\n    if (!config) {\n      throw new Error('Virtualizer constructor requires a configuration object');\n    }\n    if (config.hostElement) {\n      this._init(config);\n    } else {\n      throw new Error('Virtualizer configuration requires the \"hostElement\" property');\n    }\n  }\n  set items(items) {\n    if (Array.isArray(items) && items !== this._items) {\n      this._itemsChanged = true;\n      this._items = items;\n      this._schedule(this._updateLayout);\n    }\n  }\n  _init(config) {\n    this._isScroller = !!config.scroller;\n    this._initHostElement(config);\n    // If no layout is specified, we make an empty\n    // layout config, which will result in the default\n    // layout with default parameters\n    this._initLayout(config.layout || {});\n  }\n  _initObservers() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this._mutationObserver = new MutationObserver(_this._finishDOMUpdate.bind(_this));\n      const ResizeObserver = yield getResizeObserver();\n      _this._hostElementRO = new ResizeObserver(() => _this._hostElementSizeChanged());\n      _this._childrenRO = new ResizeObserver(_this._childrenSizeChanged.bind(_this));\n    })();\n  }\n  _initHostElement(config) {\n    const hostElement = this._hostElement = config.hostElement;\n    this._applyVirtualizerStyles();\n    hostElement[virtualizerRef] = this;\n  }\n  connected() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      yield _this2._initObservers();\n      const includeSelf = _this2._isScroller;\n      _this2._clippingAncestors = getClippingAncestors(_this2._hostElement, includeSelf);\n      _this2._scrollerController = new ScrollerController(_this2, _this2._clippingAncestors[0]);\n      _this2._schedule(_this2._updateLayout);\n      _this2._observeAndListen();\n    })();\n  }\n  _observeAndListen() {\n    this._mutationObserver.observe(this._hostElement, {\n      childList: true\n    });\n    this._hostElementRO.observe(this._hostElement);\n    this._scrollEventListeners.push(window);\n    window.addEventListener('scroll', this, this._scrollEventListenerOptions);\n    this._clippingAncestors.forEach(ancestor => {\n      ancestor.addEventListener('scroll', this, this._scrollEventListenerOptions);\n      this._scrollEventListeners.push(ancestor);\n      this._hostElementRO.observe(ancestor);\n    });\n    this._hostElementRO.observe(this._scrollerController.element);\n    this._children.forEach(child => this._childrenRO.observe(child));\n    this._scrollEventListeners.forEach(target => target.addEventListener('scroll', this, this._scrollEventListenerOptions));\n  }\n  disconnected() {\n    var _a, _b, _c, _d;\n    this._scrollEventListeners.forEach(target => target.removeEventListener('scroll', this, this._scrollEventListenerOptions));\n    this._scrollEventListeners = [];\n    this._clippingAncestors = [];\n    this._scrollerController = ((_a = this._scrollerController) === null || _a === void 0 ? void 0 : _a.detach(this)) || null;\n    (_b = this._mutationObserver) === null || _b === void 0 ? void 0 : _b.disconnect();\n    (_c = this._hostElementRO) === null || _c === void 0 ? void 0 : _c.disconnect();\n    (_d = this._childrenRO) === null || _d === void 0 ? void 0 : _d.disconnect();\n    this._rejectLayoutCompletePromise('disconnected');\n  }\n  _applyVirtualizerStyles() {\n    const hostElement = this._hostElement;\n    // Would rather set these CSS properties on the host using Shadow Root\n    // style scoping (and falling back to a global stylesheet where native\n    // Shadow DOM is not available), but this Mobile Safari bug is preventing\n    // that from working: https://bugs.webkit.org/show_bug.cgi?id=226195\n    const style = hostElement.style;\n    style.display = style.display || 'block';\n    style.position = style.position || 'relative';\n    style.contain = style.contain || 'size layout';\n    if (this._isScroller) {\n      style.overflow = style.overflow || 'auto';\n      style.minHeight = style.minHeight || '150px';\n    }\n  }\n  _getSizer() {\n    const hostElement = this._hostElement;\n    if (!this._sizer) {\n      // Use a pre-existing sizer element if provided (for better integration\n      // with vDOM renderers)\n      let sizer = hostElement.querySelector(`[${SIZER_ATTRIBUTE}]`);\n      if (!sizer) {\n        sizer = document.createElement('div');\n        sizer.setAttribute(SIZER_ATTRIBUTE, '');\n        hostElement.appendChild(sizer);\n      }\n      // When the scrollHeight is large, the height of this element might be\n      // ignored. Setting content and font-size ensures the element has a size.\n      Object.assign(sizer.style, {\n        position: 'absolute',\n        margin: '-2px 0 0 0',\n        padding: 0,\n        visibility: 'hidden',\n        fontSize: '2px'\n      });\n      sizer.innerHTML = '&nbsp;';\n      sizer.setAttribute(SIZER_ATTRIBUTE, '');\n      this._sizer = sizer;\n    }\n    return this._sizer;\n  }\n  updateLayoutConfig(layoutConfig) {\n    const Ctor = layoutConfig.type || DefaultLayoutConstructor;\n    if (typeof Ctor === 'function' && this._layout instanceof Ctor) {\n      const config = {\n        ...layoutConfig\n      };\n      delete config.type;\n      this._layout.config = config;\n      return true;\n    }\n    return false;\n  }\n  _initLayout(layoutConfig) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      let config;\n      let Ctor;\n      if (typeof layoutConfig.type === 'function') {\n        // If we have a full LayoutSpecifier, the `type` property\n        // gives us our constructor...\n        Ctor = layoutConfig.type;\n        // ...while the rest of the specifier is our layout config\n        const copy = {\n          ...layoutConfig\n        };\n        delete copy.type;\n        config = copy;\n      } else {\n        // If we don't have a full LayoutSpecifier, we just\n        // have a config for the default layout\n        config = layoutConfig;\n      }\n      if (Ctor === undefined) {\n        // If we don't have a constructor yet, load the default\n        DefaultLayoutConstructor = Ctor = (yield import('./layouts/flow.js')).FlowLayout;\n      }\n      _this3._layout = new Ctor(config);\n      if (_this3._layout.measureChildren && typeof _this3._layout.updateItemSizes === 'function') {\n        if (typeof _this3._layout.measureChildren === 'function') {\n          _this3._measureChildOverride = _this3._layout.measureChildren;\n        }\n        _this3._measureCallback = _this3._layout.updateItemSizes.bind(_this3._layout);\n      }\n      _this3._layout.addEventListener('scrollsizechange', _this3);\n      _this3._layout.addEventListener('scrollerrorchange', _this3);\n      _this3._layout.addEventListener('itempositionchange', _this3);\n      _this3._layout.addEventListener('rangechange', _this3);\n      _this3._layout.addEventListener('unpinned', _this3);\n      if (_this3._layout.listenForChildLoadEvents) {\n        _this3._hostElement.addEventListener('load', _this3._loadListener, true);\n      }\n      _this3._schedule(_this3._updateLayout);\n    })();\n  }\n  // TODO (graynorton): Rework benchmarking so that it has no API and\n  // instead is always on except in production builds\n  startBenchmarking() {\n    if (this._benchmarkStart === null) {\n      this._benchmarkStart = window.performance.now();\n    }\n  }\n  stopBenchmarking() {\n    if (this._benchmarkStart !== null) {\n      const now = window.performance.now();\n      const timeElapsed = now - this._benchmarkStart;\n      const entries = performance.getEntriesByName('uv-virtualizing', 'measure');\n      const virtualizationTime = entries.filter(e => e.startTime >= this._benchmarkStart && e.startTime < now).reduce((t, m) => t + m.duration, 0);\n      this._benchmarkStart = null;\n      return {\n        timeElapsed,\n        virtualizationTime\n      };\n    }\n    return null;\n  }\n  _measureChildren() {\n    const mm = {};\n    const children = this._children;\n    const fn = this._measureChildOverride || this._measureChild;\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const idx = this._first + i;\n      if (this._itemsChanged || this._toBeMeasured.has(child)) {\n        mm[idx] = fn.call(this, child, this._items[idx]);\n      }\n    }\n    this._childMeasurements = mm;\n    this._schedule(this._updateLayout);\n    this._toBeMeasured.clear();\n  }\n  /**\n   * Returns the width, height, and margins of the given child.\n   */\n  _measureChild(element) {\n    // offsetWidth doesn't take transforms in consideration, so we use\n    // getBoundingClientRect which does.\n    const {\n      width,\n      height\n    } = element.getBoundingClientRect();\n    return Object.assign({\n      width,\n      height\n    }, getMargins(element));\n  }\n  _schedule(method) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this4._scheduled.has(method)) {\n        _this4._scheduled.add(method);\n        yield Promise.resolve();\n        _this4._scheduled.delete(method);\n        method.call(_this4);\n      }\n    })();\n  }\n  _updateDOM() {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        _rangeChanged,\n        _itemsChanged\n      } = _this5;\n      if (_this5._visibilityChanged) {\n        _this5._notifyVisibility();\n        _this5._visibilityChanged = false;\n      }\n      if (_rangeChanged || _itemsChanged) {\n        _this5._notifyRange();\n        _this5._rangeChanged = false;\n      } else {\n        _this5._finishDOMUpdate();\n      }\n    })();\n  }\n  _finishDOMUpdate() {\n    this._children.forEach(child => this._childrenRO.observe(child));\n    this._checkScrollIntoViewTarget(this._childrenPos);\n    this._positionChildren(this._childrenPos);\n    this._sizeHostElement(this._scrollSize);\n    this._correctScrollError();\n    if (this._benchmarkStart && 'mark' in window.performance) {\n      window.performance.mark('uv-end');\n    }\n  }\n  _updateLayout() {\n    if (this._layout) {\n      this._layout.items = this._items;\n      this._updateView();\n      if (this._childMeasurements !== null) {\n        // If the layout has been changed, we may have measurements but no callback\n        if (this._measureCallback) {\n          this._measureCallback(this._childMeasurements);\n        }\n        this._childMeasurements = null;\n      }\n      this._layout.reflowIfNeeded();\n      if (this._benchmarkStart && 'mark' in window.performance) {\n        window.performance.mark('uv-end');\n      }\n    }\n  }\n  _handleScrollEvent() {\n    var _a;\n    if (this._benchmarkStart && 'mark' in window.performance) {\n      try {\n        window.performance.measure('uv-virtualizing', 'uv-start', 'uv-end');\n      } catch (e) {\n        console.warn('Error measuring performance data: ', e);\n      }\n      window.performance.mark('uv-start');\n    }\n    if (this._scrollerController.correctingScrollError === false) {\n      // This is a user-initiated scroll, so we unpin the layout\n      (_a = this._layout) === null || _a === void 0 ? void 0 : _a.unpin();\n    }\n    this._schedule(this._updateLayout);\n  }\n  handleEvent(event) {\n    switch (event.type) {\n      case 'scroll':\n        if (event.currentTarget === window || this._clippingAncestors.includes(event.currentTarget)) {\n          this._handleScrollEvent();\n        }\n        break;\n      case 'scrollsizechange':\n        this._scrollSize = event.detail;\n        this._schedule(this._updateDOM);\n        break;\n      case 'scrollerrorchange':\n        this._scrollError = event.detail;\n        this._schedule(this._updateDOM);\n        break;\n      case 'itempositionchange':\n        this._childrenPos = event.detail;\n        this._schedule(this._updateDOM);\n        break;\n      case 'rangechange':\n        this._adjustRange(event.detail);\n        this._schedule(this._updateDOM);\n        break;\n      case 'unpinned':\n        this._hostElement.dispatchEvent(new UnpinnedEvent());\n        break;\n      default:\n        console.warn('event not handled', event);\n    }\n  }\n  get _children() {\n    const arr = [];\n    let next = this._hostElement.firstElementChild;\n    while (next) {\n      if (!next.hasAttribute(SIZER_ATTRIBUTE)) {\n        arr.push(next);\n      }\n      next = next.nextElementSibling;\n    }\n    return arr;\n  }\n  _updateView() {\n    var _a;\n    const hostElement = this._hostElement;\n    const scrollingElement = (_a = this._scrollerController) === null || _a === void 0 ? void 0 : _a.element;\n    const layout = this._layout;\n    if (hostElement && scrollingElement && layout) {\n      let top, left, bottom, right;\n      const hostElementBounds = hostElement.getBoundingClientRect();\n      top = 0;\n      left = 0;\n      bottom = window.innerHeight;\n      right = window.innerWidth;\n      const ancestorBounds = this._clippingAncestors.map(ancestor => ancestor.getBoundingClientRect());\n      ancestorBounds.unshift(hostElementBounds);\n      for (const bounds of ancestorBounds) {\n        top = Math.max(top, bounds.top);\n        left = Math.max(left, bounds.left);\n        bottom = Math.min(bottom, bounds.bottom);\n        right = Math.min(right, bounds.right);\n      }\n      const scrollingElementBounds = scrollingElement.getBoundingClientRect();\n      const offsetWithinScroller = {\n        left: hostElementBounds.left - scrollingElementBounds.left,\n        top: hostElementBounds.top - scrollingElementBounds.top\n      };\n      const totalScrollSize = {\n        width: scrollingElement.scrollWidth,\n        height: scrollingElement.scrollHeight\n      };\n      const scrollTop = top - hostElementBounds.top + hostElement.scrollTop;\n      const scrollLeft = left - hostElementBounds.left + hostElement.scrollLeft;\n      const height = Math.max(1, bottom - top);\n      const width = Math.max(1, right - left);\n      layout.viewportSize = {\n        width,\n        height\n      };\n      layout.viewportScroll = {\n        top: scrollTop,\n        left: scrollLeft\n      };\n      layout.totalScrollSize = totalScrollSize;\n      layout.offsetWithinScroller = offsetWithinScroller;\n    }\n  }\n  /**\n   * Styles the host element so that its size reflects the\n   * total size of all items.\n   */\n  _sizeHostElement(size) {\n    // Some browsers seem to crap out if the host element gets larger than\n    // a certain size, so we clamp it here (this value based on ad hoc\n    // testing in Chrome / Safari / Firefox Mac)\n    const max = 8200000;\n    const h = size && size.width !== null ? Math.min(max, size.width) : 0;\n    const v = size && size.height !== null ? Math.min(max, size.height) : 0;\n    if (this._isScroller) {\n      this._getSizer().style.transform = `translate(${h}px, ${v}px)`;\n    } else {\n      const style = this._hostElement.style;\n      style.minWidth = h ? `${h}px` : '100%';\n      style.minHeight = v ? `${v}px` : '100%';\n    }\n  }\n  /**\n   * Sets the top and left transform style of the children from the values in\n   * pos.\n   */\n  _positionChildren(pos) {\n    if (pos) {\n      pos.forEach(({\n        top,\n        left,\n        width,\n        height,\n        xOffset,\n        yOffset\n      }, index) => {\n        const child = this._children[index - this._first];\n        if (child) {\n          child.style.position = 'absolute';\n          child.style.boxSizing = 'border-box';\n          child.style.transform = `translate(${left}px, ${top}px)`;\n          if (width !== undefined) {\n            child.style.width = width + 'px';\n          }\n          if (height !== undefined) {\n            child.style.height = height + 'px';\n          }\n          child.style.left = xOffset === undefined ? null : xOffset + 'px';\n          child.style.top = yOffset === undefined ? null : yOffset + 'px';\n        }\n      });\n    }\n  }\n  _adjustRange(range) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const {\n        _first,\n        _last,\n        _firstVisible,\n        _lastVisible\n      } = _this6;\n      _this6._first = range.first;\n      _this6._last = range.last;\n      _this6._firstVisible = range.firstVisible;\n      _this6._lastVisible = range.lastVisible;\n      _this6._rangeChanged = _this6._rangeChanged || _this6._first !== _first || _this6._last !== _last;\n      _this6._visibilityChanged = _this6._visibilityChanged || _this6._firstVisible !== _firstVisible || _this6._lastVisible !== _lastVisible;\n    })();\n  }\n  _correctScrollError() {\n    if (this._scrollError) {\n      const {\n        scrollTop,\n        scrollLeft\n      } = this._scrollerController;\n      const {\n        top,\n        left\n      } = this._scrollError;\n      this._scrollError = null;\n      this._scrollerController.correctScrollError({\n        top: scrollTop - top,\n        left: scrollLeft - left\n      });\n    }\n  }\n  element(index) {\n    var _a;\n    if (index === Infinity) {\n      index = this._items.length - 1;\n    }\n    return ((_a = this._items) === null || _a === void 0 ? void 0 : _a[index]) === undefined ? undefined : {\n      scrollIntoView: (options = {}) => this._scrollElementIntoView({\n        ...options,\n        index\n      })\n    };\n  }\n  _scrollElementIntoView(options) {\n    if (options.index >= this._first && options.index <= this._last) {\n      this._children[options.index - this._first].scrollIntoView(options);\n    } else {\n      options.index = Math.min(options.index, this._items.length - 1);\n      if (options.behavior === 'smooth') {\n        const coordinates = this._layout.getScrollIntoViewCoordinates(options);\n        const {\n          behavior\n        } = options;\n        this._updateScrollIntoViewCoordinates = this._scrollerController.managedScrollTo(Object.assign(coordinates, {\n          behavior\n        }), () => this._layout.getScrollIntoViewCoordinates(options), () => this._scrollIntoViewTarget = null);\n        this._scrollIntoViewTarget = options;\n      } else {\n        this._layout.pin = options;\n      }\n    }\n  }\n  /**\n   * If we are smoothly scrolling to an element and the target element\n   * is in the DOM, we update our target coordinates as needed\n   */\n  _checkScrollIntoViewTarget(pos) {\n    const {\n      index\n    } = this._scrollIntoViewTarget || {};\n    if (index && (pos === null || pos === void 0 ? void 0 : pos.has(index))) {\n      this._updateScrollIntoViewCoordinates(this._layout.getScrollIntoViewCoordinates(this._scrollIntoViewTarget));\n    }\n  }\n  /**\n   * Emits a rangechange event with the current first, last, firstVisible, and\n   * lastVisible.\n   */\n  _notifyRange() {\n    this._hostElement.dispatchEvent(new RangeChangedEvent({\n      first: this._first,\n      last: this._last\n    }));\n  }\n  _notifyVisibility() {\n    this._hostElement.dispatchEvent(new VisibilityChangedEvent({\n      first: this._firstVisible,\n      last: this._lastVisible\n    }));\n  }\n  get layoutComplete() {\n    // Lazily create promise\n    if (!this._layoutCompletePromise) {\n      this._layoutCompletePromise = new Promise((resolve, reject) => {\n        this._layoutCompleteResolver = resolve;\n        this._layoutCompleteRejecter = reject;\n      });\n    }\n    return this._layoutCompletePromise;\n  }\n  _rejectLayoutCompletePromise(reason) {\n    if (this._layoutCompleteRejecter !== null) {\n      this._layoutCompleteRejecter(reason);\n    }\n    this._resetLayoutCompleteState();\n  }\n  _scheduleLayoutComplete() {\n    // Don't do anything unless we have a pending promise\n    // And only request a frame if we haven't already done so\n    if (this._layoutCompletePromise && this._pendingLayoutComplete === null) {\n      // Wait one additional frame to be sure the layout is stable\n      this._pendingLayoutComplete = requestAnimationFrame(() => requestAnimationFrame(() => this._resolveLayoutCompletePromise()));\n    }\n  }\n  _resolveLayoutCompletePromise() {\n    if (this._layoutCompleteResolver !== null) {\n      this._layoutCompleteResolver();\n    }\n    this._resetLayoutCompleteState();\n  }\n  _resetLayoutCompleteState() {\n    this._layoutCompletePromise = null;\n    this._layoutCompleteResolver = null;\n    this._layoutCompleteRejecter = null;\n    this._pendingLayoutComplete = null;\n  }\n  /**\n   * Render and update the view at the next opportunity with the given\n   * hostElement size.\n   */\n  _hostElementSizeChanged() {\n    this._schedule(this._updateLayout);\n  }\n  // TODO (graynorton): Rethink how this works. Probably child loading is too specific\n  // to have dedicated support for; might want some more generic lifecycle hooks for\n  // layouts to use. Possibly handle measurement this way, too, or maybe that remains\n  // a first-class feature?\n  _childLoaded() {}\n  // This is the callback for the ResizeObserver that watches the\n  // virtualizer's children. We land here at the end of every virtualizer\n  // update cycle that results in changes to physical items, and we also\n  // end up here if one or more children change size independently of\n  // the virtualizer update cycle.\n  _childrenSizeChanged(changes) {\n    // Only measure if the layout requires it\n    if (this._layout.measureChildren) {\n      for (const change of changes) {\n        this._toBeMeasured.set(change.target, change.contentRect);\n      }\n      this._measureChildren();\n    }\n    // If this is the end of an update cycle, we need to reset some\n    // internal state. This should be a harmless no-op if we're handling\n    // an out-of-cycle ResizeObserver callback, so we don't need to\n    // distinguish between the two cases.\n    this._scheduleLayoutComplete();\n    this._itemsChanged = false;\n    this._rangeChanged = false;\n  }\n}\nfunction getMargins(el) {\n  const style = window.getComputedStyle(el);\n  return {\n    marginTop: getMarginValue(style.marginTop),\n    marginRight: getMarginValue(style.marginRight),\n    marginBottom: getMarginValue(style.marginBottom),\n    marginLeft: getMarginValue(style.marginLeft)\n  };\n}\nfunction getMarginValue(value) {\n  const float = value ? parseFloat(value) : NaN;\n  return Number.isNaN(float) ? 0 : float;\n}\n// TODO (graynorton): Deal with iframes?\nfunction getParentElement(el) {\n  if (el.assignedSlot !== null) {\n    return el.assignedSlot;\n  }\n  if (el.parentElement !== null) {\n    return el.parentElement;\n  }\n  const parentNode = el.parentNode;\n  if (parentNode && parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n    return parentNode.host || null;\n  }\n  return null;\n}\n///\nfunction getElementAncestors(el, includeSelf = false) {\n  const ancestors = [];\n  let parent = includeSelf ? el : getParentElement(el);\n  while (parent !== null) {\n    ancestors.push(parent);\n    parent = getParentElement(parent);\n  }\n  return ancestors;\n}\nfunction getClippingAncestors(el, includeSelf = false) {\n  return getElementAncestors(el, includeSelf).filter(a => getComputedStyle(a).overflow !== 'visible');\n}","map":{"version":3,"names":["getResizeObserver","RangeChangedEvent","VisibilityChangedEvent","UnpinnedEvent","ScrollerController","virtualizerRef","Symbol","SIZER_ATTRIBUTE","DefaultLayoutConstructor","Virtualizer","constructor","config","_benchmarkStart","_layout","_clippingAncestors","_scrollSize","_scrollError","_childrenPos","_childMeasurements","_toBeMeasured","Map","_rangeChanged","_itemsChanged","_visibilityChanged","_scrollerController","_isScroller","_sizer","_hostElementRO","_childrenRO","_mutationObserver","_scrollEventListeners","_scrollEventListenerOptions","passive","_loadListener","_childLoaded","bind","_scrollIntoViewTarget","_updateScrollIntoViewCoordinates","_items","_first","_last","_firstVisible","_lastVisible","_scheduled","WeakSet","_measureCallback","_measureChildOverride","_layoutCompletePromise","_layoutCompleteResolver","_layoutCompleteRejecter","_pendingLayoutComplete","Error","hostElement","_init","items","Array","isArray","_schedule","_updateLayout","scroller","_initHostElement","_initLayout","layout","_initObservers","MutationObserver","_finishDOMUpdate","ResizeObserver","_hostElementSizeChanged","_childrenSizeChanged","_hostElement","_applyVirtualizerStyles","connected","includeSelf","getClippingAncestors","_observeAndListen","observe","childList","push","window","addEventListener","forEach","ancestor","element","_children","child","target","disconnected","_a","_b","_c","_d","removeEventListener","detach","disconnect","_rejectLayoutCompletePromise","style","display","position","contain","overflow","minHeight","_getSizer","sizer","querySelector","document","createElement","setAttribute","appendChild","Object","assign","margin","padding","visibility","fontSize","innerHTML","updateLayoutConfig","layoutConfig","Ctor","type","copy","undefined","FlowLayout","measureChildren","updateItemSizes","listenForChildLoadEvents","startBenchmarking","performance","now","stopBenchmarking","timeElapsed","entries","getEntriesByName","virtualizationTime","filter","e","startTime","reduce","t","m","duration","_measureChildren","mm","children","fn","_measureChild","i","length","idx","has","call","clear","width","height","getBoundingClientRect","getMargins","method","add","Promise","resolve","delete","_updateDOM","_notifyVisibility","_notifyRange","_checkScrollIntoViewTarget","_positionChildren","_sizeHostElement","_correctScrollError","mark","_updateView","reflowIfNeeded","_handleScrollEvent","measure","console","warn","correctingScrollError","unpin","handleEvent","event","currentTarget","includes","detail","_adjustRange","dispatchEvent","arr","next","firstElementChild","hasAttribute","nextElementSibling","scrollingElement","top","left","bottom","right","hostElementBounds","innerHeight","innerWidth","ancestorBounds","map","unshift","bounds","Math","max","min","scrollingElementBounds","offsetWithinScroller","totalScrollSize","scrollWidth","scrollHeight","scrollTop","scrollLeft","viewportSize","viewportScroll","size","h","v","transform","minWidth","pos","xOffset","yOffset","index","boxSizing","range","first","last","firstVisible","lastVisible","correctScrollError","Infinity","scrollIntoView","options","_scrollElementIntoView","behavior","coordinates","getScrollIntoViewCoordinates","managedScrollTo","pin","layoutComplete","reject","reason","_resetLayoutCompleteState","_scheduleLayoutComplete","requestAnimationFrame","_resolveLayoutCompletePromise","changes","change","set","contentRect","el","getComputedStyle","marginTop","getMarginValue","marginRight","marginBottom","marginLeft","value","float","parseFloat","NaN","Number","isNaN","getParentElement","assignedSlot","parentElement","parentNode","nodeType","Node","DOCUMENT_FRAGMENT_NODE","host","getElementAncestors","ancestors","parent","a"],"sources":["/Users/tima/kbtu/4thSemester/web/Lab4/angular/node_modules/@lit-labs/virtualizer/Virtualizer.js"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport getResizeObserver from './polyfillLoaders/ResizeObserver.js';\nimport { RangeChangedEvent, VisibilityChangedEvent, UnpinnedEvent, } from './events.js';\nimport { ScrollerController } from './ScrollerController.js';\nexport const virtualizerRef = Symbol('virtualizerRef');\nconst SIZER_ATTRIBUTE = 'virtualizer-sizer';\nlet DefaultLayoutConstructor;\n/**\n * Provides virtual scrolling boilerplate.\n *\n * Extensions of this class must set hostElement and layout.\n *\n * Extensions of this class must also override VirtualRepeater's DOM\n * manipulation methods.\n */\nexport class Virtualizer {\n    constructor(config) {\n        this._benchmarkStart = null;\n        this._layout = null;\n        this._clippingAncestors = [];\n        /**\n         * Layout provides these values, we set them on _render().\n         * TODO @straversi: Can we find an XOR type, usable for the key here?\n         */\n        this._scrollSize = null;\n        /**\n         * Difference between scroll target's current and required scroll offsets.\n         * Provided by layout.\n         */\n        this._scrollError = null;\n        /**\n         * A list of the positions (top, left) of the children in the current range.\n         */\n        this._childrenPos = null;\n        // TODO: (graynorton): type\n        this._childMeasurements = null;\n        this._toBeMeasured = new Map();\n        this._rangeChanged = true;\n        this._itemsChanged = true;\n        this._visibilityChanged = true;\n        this._scrollerController = null;\n        this._isScroller = false;\n        this._sizer = null;\n        /**\n         * Resize observer attached to hostElement.\n         */\n        this._hostElementRO = null;\n        /**\n         * Resize observer attached to children.\n         */\n        this._childrenRO = null;\n        this._mutationObserver = null;\n        this._scrollEventListeners = [];\n        this._scrollEventListenerOptions = {\n            passive: true,\n        };\n        // TODO (graynorton): Rethink, per longer comment below\n        this._loadListener = this._childLoaded.bind(this);\n        /**\n         * Index of element to scroll into view, plus scroll\n         * behavior options, as imperatively specified via\n         * `element(index).scrollIntoView()`\n         */\n        this._scrollIntoViewTarget = null;\n        this._updateScrollIntoViewCoordinates = null;\n        /**\n         * Items to render. Set by items.\n         */\n        this._items = [];\n        /**\n         * Index of the first child in the range, not necessarily the first visible child.\n         * TODO @straversi: Consider renaming these.\n         */\n        this._first = -1;\n        /**\n         * Index of the last child in the range.\n         */\n        this._last = -1;\n        /**\n         * Index of the first item intersecting the viewport.\n         */\n        this._firstVisible = -1;\n        /**\n         * Index of the last item intersecting the viewport.\n         */\n        this._lastVisible = -1;\n        this._scheduled = new WeakSet();\n        /**\n         * Invoked at the end of each render cycle: children in the range are\n         * measured, and their dimensions passed to this callback. Use it to layout\n         * children as needed.\n         */\n        this._measureCallback = null;\n        this._measureChildOverride = null;\n        /**\n         * State for `layoutComplete` promise\n         */\n        this._layoutCompletePromise = null;\n        this._layoutCompleteResolver = null;\n        this._layoutCompleteRejecter = null;\n        this._pendingLayoutComplete = null;\n        if (!config) {\n            throw new Error('Virtualizer constructor requires a configuration object');\n        }\n        if (config.hostElement) {\n            this._init(config);\n        }\n        else {\n            throw new Error('Virtualizer configuration requires the \"hostElement\" property');\n        }\n    }\n    set items(items) {\n        if (Array.isArray(items) && items !== this._items) {\n            this._itemsChanged = true;\n            this._items = items;\n            this._schedule(this._updateLayout);\n        }\n    }\n    _init(config) {\n        this._isScroller = !!config.scroller;\n        this._initHostElement(config);\n        // If no layout is specified, we make an empty\n        // layout config, which will result in the default\n        // layout with default parameters\n        this._initLayout(config.layout || {});\n    }\n    async _initObservers() {\n        this._mutationObserver = new MutationObserver(this._finishDOMUpdate.bind(this));\n        const ResizeObserver = await getResizeObserver();\n        this._hostElementRO = new ResizeObserver(() => this._hostElementSizeChanged());\n        this._childrenRO = new ResizeObserver(this._childrenSizeChanged.bind(this));\n    }\n    _initHostElement(config) {\n        const hostElement = (this._hostElement = config.hostElement);\n        this._applyVirtualizerStyles();\n        hostElement[virtualizerRef] = this;\n    }\n    async connected() {\n        await this._initObservers();\n        const includeSelf = this._isScroller;\n        this._clippingAncestors = getClippingAncestors(this._hostElement, includeSelf);\n        this._scrollerController = new ScrollerController(this, this._clippingAncestors[0]);\n        this._schedule(this._updateLayout);\n        this._observeAndListen();\n    }\n    _observeAndListen() {\n        this._mutationObserver.observe(this._hostElement, { childList: true });\n        this._hostElementRO.observe(this._hostElement);\n        this._scrollEventListeners.push(window);\n        window.addEventListener('scroll', this, this._scrollEventListenerOptions);\n        this._clippingAncestors.forEach((ancestor) => {\n            ancestor.addEventListener('scroll', this, this._scrollEventListenerOptions);\n            this._scrollEventListeners.push(ancestor);\n            this._hostElementRO.observe(ancestor);\n        });\n        this._hostElementRO.observe(this._scrollerController.element);\n        this._children.forEach((child) => this._childrenRO.observe(child));\n        this._scrollEventListeners.forEach((target) => target.addEventListener('scroll', this, this._scrollEventListenerOptions));\n    }\n    disconnected() {\n        var _a, _b, _c, _d;\n        this._scrollEventListeners.forEach((target) => target.removeEventListener('scroll', this, this._scrollEventListenerOptions));\n        this._scrollEventListeners = [];\n        this._clippingAncestors = [];\n        this._scrollerController = ((_a = this._scrollerController) === null || _a === void 0 ? void 0 : _a.detach(this)) || null;\n        (_b = this._mutationObserver) === null || _b === void 0 ? void 0 : _b.disconnect();\n        (_c = this._hostElementRO) === null || _c === void 0 ? void 0 : _c.disconnect();\n        (_d = this._childrenRO) === null || _d === void 0 ? void 0 : _d.disconnect();\n        this._rejectLayoutCompletePromise('disconnected');\n    }\n    _applyVirtualizerStyles() {\n        const hostElement = this._hostElement;\n        // Would rather set these CSS properties on the host using Shadow Root\n        // style scoping (and falling back to a global stylesheet where native\n        // Shadow DOM is not available), but this Mobile Safari bug is preventing\n        // that from working: https://bugs.webkit.org/show_bug.cgi?id=226195\n        const style = hostElement.style;\n        style.display = style.display || 'block';\n        style.position = style.position || 'relative';\n        style.contain = style.contain || 'size layout';\n        if (this._isScroller) {\n            style.overflow = style.overflow || 'auto';\n            style.minHeight = style.minHeight || '150px';\n        }\n    }\n    _getSizer() {\n        const hostElement = this._hostElement;\n        if (!this._sizer) {\n            // Use a pre-existing sizer element if provided (for better integration\n            // with vDOM renderers)\n            let sizer = hostElement.querySelector(`[${SIZER_ATTRIBUTE}]`);\n            if (!sizer) {\n                sizer = document.createElement('div');\n                sizer.setAttribute(SIZER_ATTRIBUTE, '');\n                hostElement.appendChild(sizer);\n            }\n            // When the scrollHeight is large, the height of this element might be\n            // ignored. Setting content and font-size ensures the element has a size.\n            Object.assign(sizer.style, {\n                position: 'absolute',\n                margin: '-2px 0 0 0',\n                padding: 0,\n                visibility: 'hidden',\n                fontSize: '2px',\n            });\n            sizer.innerHTML = '&nbsp;';\n            sizer.setAttribute(SIZER_ATTRIBUTE, '');\n            this._sizer = sizer;\n        }\n        return this._sizer;\n    }\n    updateLayoutConfig(layoutConfig) {\n        const Ctor = layoutConfig.type ||\n            DefaultLayoutConstructor;\n        if (typeof Ctor === 'function' && this._layout instanceof Ctor) {\n            const config = { ...layoutConfig };\n            delete config.type;\n            this._layout.config = config;\n            return true;\n        }\n        return false;\n    }\n    async _initLayout(layoutConfig) {\n        let config;\n        let Ctor;\n        if (typeof layoutConfig.type === 'function') {\n            // If we have a full LayoutSpecifier, the `type` property\n            // gives us our constructor...\n            Ctor = layoutConfig.type;\n            // ...while the rest of the specifier is our layout config\n            const copy = { ...layoutConfig };\n            delete copy.type;\n            config = copy;\n        }\n        else {\n            // If we don't have a full LayoutSpecifier, we just\n            // have a config for the default layout\n            config = layoutConfig;\n        }\n        if (Ctor === undefined) {\n            // If we don't have a constructor yet, load the default\n            DefaultLayoutConstructor = Ctor = (await import('./layouts/flow.js'))\n                .FlowLayout;\n        }\n        this._layout = new Ctor(config);\n        if (this._layout.measureChildren &&\n            typeof this._layout.updateItemSizes === 'function') {\n            if (typeof this._layout.measureChildren === 'function') {\n                this._measureChildOverride = this._layout.measureChildren;\n            }\n            this._measureCallback = this._layout.updateItemSizes.bind(this._layout);\n        }\n        this._layout.addEventListener('scrollsizechange', this);\n        this._layout.addEventListener('scrollerrorchange', this);\n        this._layout.addEventListener('itempositionchange', this);\n        this._layout.addEventListener('rangechange', this);\n        this._layout.addEventListener('unpinned', this);\n        if (this._layout.listenForChildLoadEvents) {\n            this._hostElement.addEventListener('load', this._loadListener, true);\n        }\n        this._schedule(this._updateLayout);\n    }\n    // TODO (graynorton): Rework benchmarking so that it has no API and\n    // instead is always on except in production builds\n    startBenchmarking() {\n        if (this._benchmarkStart === null) {\n            this._benchmarkStart = window.performance.now();\n        }\n    }\n    stopBenchmarking() {\n        if (this._benchmarkStart !== null) {\n            const now = window.performance.now();\n            const timeElapsed = now - this._benchmarkStart;\n            const entries = performance.getEntriesByName('uv-virtualizing', 'measure');\n            const virtualizationTime = entries\n                .filter((e) => e.startTime >= this._benchmarkStart && e.startTime < now)\n                .reduce((t, m) => t + m.duration, 0);\n            this._benchmarkStart = null;\n            return { timeElapsed, virtualizationTime };\n        }\n        return null;\n    }\n    _measureChildren() {\n        const mm = {};\n        const children = this._children;\n        const fn = this._measureChildOverride || this._measureChild;\n        for (let i = 0; i < children.length; i++) {\n            const child = children[i];\n            const idx = this._first + i;\n            if (this._itemsChanged || this._toBeMeasured.has(child)) {\n                mm[idx] = fn.call(this, child, this._items[idx]);\n            }\n        }\n        this._childMeasurements = mm;\n        this._schedule(this._updateLayout);\n        this._toBeMeasured.clear();\n    }\n    /**\n     * Returns the width, height, and margins of the given child.\n     */\n    _measureChild(element) {\n        // offsetWidth doesn't take transforms in consideration, so we use\n        // getBoundingClientRect which does.\n        const { width, height } = element.getBoundingClientRect();\n        return Object.assign({ width, height }, getMargins(element));\n    }\n    async _schedule(method) {\n        if (!this._scheduled.has(method)) {\n            this._scheduled.add(method);\n            await Promise.resolve();\n            this._scheduled.delete(method);\n            method.call(this);\n        }\n    }\n    async _updateDOM() {\n        const { _rangeChanged, _itemsChanged } = this;\n        if (this._visibilityChanged) {\n            this._notifyVisibility();\n            this._visibilityChanged = false;\n        }\n        if (_rangeChanged || _itemsChanged) {\n            this._notifyRange();\n            this._rangeChanged = false;\n        }\n        else {\n            this._finishDOMUpdate();\n        }\n    }\n    _finishDOMUpdate() {\n        this._children.forEach((child) => this._childrenRO.observe(child));\n        this._checkScrollIntoViewTarget(this._childrenPos);\n        this._positionChildren(this._childrenPos);\n        this._sizeHostElement(this._scrollSize);\n        this._correctScrollError();\n        if (this._benchmarkStart && 'mark' in window.performance) {\n            window.performance.mark('uv-end');\n        }\n    }\n    _updateLayout() {\n        if (this._layout) {\n            this._layout.items = this._items;\n            this._updateView();\n            if (this._childMeasurements !== null) {\n                // If the layout has been changed, we may have measurements but no callback\n                if (this._measureCallback) {\n                    this._measureCallback(this._childMeasurements);\n                }\n                this._childMeasurements = null;\n            }\n            this._layout.reflowIfNeeded();\n            if (this._benchmarkStart && 'mark' in window.performance) {\n                window.performance.mark('uv-end');\n            }\n        }\n    }\n    _handleScrollEvent() {\n        var _a;\n        if (this._benchmarkStart && 'mark' in window.performance) {\n            try {\n                window.performance.measure('uv-virtualizing', 'uv-start', 'uv-end');\n            }\n            catch (e) {\n                console.warn('Error measuring performance data: ', e);\n            }\n            window.performance.mark('uv-start');\n        }\n        if (this._scrollerController.correctingScrollError === false) {\n            // This is a user-initiated scroll, so we unpin the layout\n            (_a = this._layout) === null || _a === void 0 ? void 0 : _a.unpin();\n        }\n        this._schedule(this._updateLayout);\n    }\n    handleEvent(event) {\n        switch (event.type) {\n            case 'scroll':\n                if (event.currentTarget === window ||\n                    this._clippingAncestors.includes(event.currentTarget)) {\n                    this._handleScrollEvent();\n                }\n                break;\n            case 'scrollsizechange':\n                this._scrollSize = event.detail;\n                this._schedule(this._updateDOM);\n                break;\n            case 'scrollerrorchange':\n                this._scrollError = event.detail;\n                this._schedule(this._updateDOM);\n                break;\n            case 'itempositionchange':\n                this._childrenPos = event.detail;\n                this._schedule(this._updateDOM);\n                break;\n            case 'rangechange':\n                this._adjustRange(event.detail);\n                this._schedule(this._updateDOM);\n                break;\n            case 'unpinned':\n                this._hostElement.dispatchEvent(new UnpinnedEvent());\n                break;\n            default:\n                console.warn('event not handled', event);\n        }\n    }\n    get _children() {\n        const arr = [];\n        let next = this._hostElement.firstElementChild;\n        while (next) {\n            if (!next.hasAttribute(SIZER_ATTRIBUTE)) {\n                arr.push(next);\n            }\n            next = next.nextElementSibling;\n        }\n        return arr;\n    }\n    _updateView() {\n        var _a;\n        const hostElement = this._hostElement;\n        const scrollingElement = (_a = this._scrollerController) === null || _a === void 0 ? void 0 : _a.element;\n        const layout = this._layout;\n        if (hostElement && scrollingElement && layout) {\n            let top, left, bottom, right;\n            const hostElementBounds = hostElement.getBoundingClientRect();\n            top = 0;\n            left = 0;\n            bottom = window.innerHeight;\n            right = window.innerWidth;\n            const ancestorBounds = this._clippingAncestors.map((ancestor) => ancestor.getBoundingClientRect());\n            ancestorBounds.unshift(hostElementBounds);\n            for (const bounds of ancestorBounds) {\n                top = Math.max(top, bounds.top);\n                left = Math.max(left, bounds.left);\n                bottom = Math.min(bottom, bounds.bottom);\n                right = Math.min(right, bounds.right);\n            }\n            const scrollingElementBounds = scrollingElement.getBoundingClientRect();\n            const offsetWithinScroller = {\n                left: hostElementBounds.left - scrollingElementBounds.left,\n                top: hostElementBounds.top - scrollingElementBounds.top,\n            };\n            const totalScrollSize = {\n                width: scrollingElement.scrollWidth,\n                height: scrollingElement.scrollHeight,\n            };\n            const scrollTop = top - hostElementBounds.top + hostElement.scrollTop;\n            const scrollLeft = left - hostElementBounds.left + hostElement.scrollLeft;\n            const height = Math.max(1, bottom - top);\n            const width = Math.max(1, right - left);\n            layout.viewportSize = { width, height };\n            layout.viewportScroll = { top: scrollTop, left: scrollLeft };\n            layout.totalScrollSize = totalScrollSize;\n            layout.offsetWithinScroller = offsetWithinScroller;\n        }\n    }\n    /**\n     * Styles the host element so that its size reflects the\n     * total size of all items.\n     */\n    _sizeHostElement(size) {\n        // Some browsers seem to crap out if the host element gets larger than\n        // a certain size, so we clamp it here (this value based on ad hoc\n        // testing in Chrome / Safari / Firefox Mac)\n        const max = 8200000;\n        const h = size && size.width !== null ? Math.min(max, size.width) : 0;\n        const v = size && size.height !== null ? Math.min(max, size.height) : 0;\n        if (this._isScroller) {\n            this._getSizer().style.transform = `translate(${h}px, ${v}px)`;\n        }\n        else {\n            const style = this._hostElement.style;\n            style.minWidth = h ? `${h}px` : '100%';\n            style.minHeight = v ? `${v}px` : '100%';\n        }\n    }\n    /**\n     * Sets the top and left transform style of the children from the values in\n     * pos.\n     */\n    _positionChildren(pos) {\n        if (pos) {\n            pos.forEach(({ top, left, width, height, xOffset, yOffset }, index) => {\n                const child = this._children[index - this._first];\n                if (child) {\n                    child.style.position = 'absolute';\n                    child.style.boxSizing = 'border-box';\n                    child.style.transform = `translate(${left}px, ${top}px)`;\n                    if (width !== undefined) {\n                        child.style.width = width + 'px';\n                    }\n                    if (height !== undefined) {\n                        child.style.height = height + 'px';\n                    }\n                    child.style.left =\n                        xOffset === undefined ? null : xOffset + 'px';\n                    child.style.top =\n                        yOffset === undefined ? null : yOffset + 'px';\n                }\n            });\n        }\n    }\n    async _adjustRange(range) {\n        const { _first, _last, _firstVisible, _lastVisible } = this;\n        this._first = range.first;\n        this._last = range.last;\n        this._firstVisible = range.firstVisible;\n        this._lastVisible = range.lastVisible;\n        this._rangeChanged =\n            this._rangeChanged || this._first !== _first || this._last !== _last;\n        this._visibilityChanged =\n            this._visibilityChanged ||\n                this._firstVisible !== _firstVisible ||\n                this._lastVisible !== _lastVisible;\n    }\n    _correctScrollError() {\n        if (this._scrollError) {\n            const { scrollTop, scrollLeft } = this._scrollerController;\n            const { top, left } = this._scrollError;\n            this._scrollError = null;\n            this._scrollerController.correctScrollError({\n                top: scrollTop - top,\n                left: scrollLeft - left,\n            });\n        }\n    }\n    element(index) {\n        var _a;\n        if (index === Infinity) {\n            index = this._items.length - 1;\n        }\n        return ((_a = this._items) === null || _a === void 0 ? void 0 : _a[index]) === undefined\n            ? undefined\n            : {\n                scrollIntoView: (options = {}) => this._scrollElementIntoView({ ...options, index }),\n            };\n    }\n    _scrollElementIntoView(options) {\n        if (options.index >= this._first && options.index <= this._last) {\n            this._children[options.index - this._first].scrollIntoView(options);\n        }\n        else {\n            options.index = Math.min(options.index, this._items.length - 1);\n            if (options.behavior === 'smooth') {\n                const coordinates = this._layout.getScrollIntoViewCoordinates(options);\n                const { behavior } = options;\n                this._updateScrollIntoViewCoordinates =\n                    this._scrollerController.managedScrollTo(Object.assign(coordinates, { behavior }), () => this._layout.getScrollIntoViewCoordinates(options), () => (this._scrollIntoViewTarget = null));\n                this._scrollIntoViewTarget = options;\n            }\n            else {\n                this._layout.pin = options;\n            }\n        }\n    }\n    /**\n     * If we are smoothly scrolling to an element and the target element\n     * is in the DOM, we update our target coordinates as needed\n     */\n    _checkScrollIntoViewTarget(pos) {\n        const { index } = this._scrollIntoViewTarget || {};\n        if (index && (pos === null || pos === void 0 ? void 0 : pos.has(index))) {\n            this._updateScrollIntoViewCoordinates(this._layout.getScrollIntoViewCoordinates(this._scrollIntoViewTarget));\n        }\n    }\n    /**\n     * Emits a rangechange event with the current first, last, firstVisible, and\n     * lastVisible.\n     */\n    _notifyRange() {\n        this._hostElement.dispatchEvent(new RangeChangedEvent({ first: this._first, last: this._last }));\n    }\n    _notifyVisibility() {\n        this._hostElement.dispatchEvent(new VisibilityChangedEvent({\n            first: this._firstVisible,\n            last: this._lastVisible,\n        }));\n    }\n    get layoutComplete() {\n        // Lazily create promise\n        if (!this._layoutCompletePromise) {\n            this._layoutCompletePromise = new Promise((resolve, reject) => {\n                this._layoutCompleteResolver = resolve;\n                this._layoutCompleteRejecter = reject;\n            });\n        }\n        return this._layoutCompletePromise;\n    }\n    _rejectLayoutCompletePromise(reason) {\n        if (this._layoutCompleteRejecter !== null) {\n            this._layoutCompleteRejecter(reason);\n        }\n        this._resetLayoutCompleteState();\n    }\n    _scheduleLayoutComplete() {\n        // Don't do anything unless we have a pending promise\n        // And only request a frame if we haven't already done so\n        if (this._layoutCompletePromise && this._pendingLayoutComplete === null) {\n            // Wait one additional frame to be sure the layout is stable\n            this._pendingLayoutComplete = requestAnimationFrame(() => requestAnimationFrame(() => this._resolveLayoutCompletePromise()));\n        }\n    }\n    _resolveLayoutCompletePromise() {\n        if (this._layoutCompleteResolver !== null) {\n            this._layoutCompleteResolver();\n        }\n        this._resetLayoutCompleteState();\n    }\n    _resetLayoutCompleteState() {\n        this._layoutCompletePromise = null;\n        this._layoutCompleteResolver = null;\n        this._layoutCompleteRejecter = null;\n        this._pendingLayoutComplete = null;\n    }\n    /**\n     * Render and update the view at the next opportunity with the given\n     * hostElement size.\n     */\n    _hostElementSizeChanged() {\n        this._schedule(this._updateLayout);\n    }\n    // TODO (graynorton): Rethink how this works. Probably child loading is too specific\n    // to have dedicated support for; might want some more generic lifecycle hooks for\n    // layouts to use. Possibly handle measurement this way, too, or maybe that remains\n    // a first-class feature?\n    _childLoaded() { }\n    // This is the callback for the ResizeObserver that watches the\n    // virtualizer's children. We land here at the end of every virtualizer\n    // update cycle that results in changes to physical items, and we also\n    // end up here if one or more children change size independently of\n    // the virtualizer update cycle.\n    _childrenSizeChanged(changes) {\n        // Only measure if the layout requires it\n        if (this._layout.measureChildren) {\n            for (const change of changes) {\n                this._toBeMeasured.set(change.target, change.contentRect);\n            }\n            this._measureChildren();\n        }\n        // If this is the end of an update cycle, we need to reset some\n        // internal state. This should be a harmless no-op if we're handling\n        // an out-of-cycle ResizeObserver callback, so we don't need to\n        // distinguish between the two cases.\n        this._scheduleLayoutComplete();\n        this._itemsChanged = false;\n        this._rangeChanged = false;\n    }\n}\nfunction getMargins(el) {\n    const style = window.getComputedStyle(el);\n    return {\n        marginTop: getMarginValue(style.marginTop),\n        marginRight: getMarginValue(style.marginRight),\n        marginBottom: getMarginValue(style.marginBottom),\n        marginLeft: getMarginValue(style.marginLeft),\n    };\n}\nfunction getMarginValue(value) {\n    const float = value ? parseFloat(value) : NaN;\n    return Number.isNaN(float) ? 0 : float;\n}\n// TODO (graynorton): Deal with iframes?\nfunction getParentElement(el) {\n    if (el.assignedSlot !== null) {\n        return el.assignedSlot;\n    }\n    if (el.parentElement !== null) {\n        return el.parentElement;\n    }\n    const parentNode = el.parentNode;\n    if (parentNode && parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\n        return parentNode.host || null;\n    }\n    return null;\n}\n///\nfunction getElementAncestors(el, includeSelf = false) {\n    const ancestors = [];\n    let parent = includeSelf ? el : getParentElement(el);\n    while (parent !== null) {\n        ancestors.push(parent);\n        parent = getParentElement(parent);\n    }\n    return ancestors;\n}\nfunction getClippingAncestors(el, includeSelf = false) {\n    return getElementAncestors(el, includeSelf).filter((a) => getComputedStyle(a).overflow !== 'visible');\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}