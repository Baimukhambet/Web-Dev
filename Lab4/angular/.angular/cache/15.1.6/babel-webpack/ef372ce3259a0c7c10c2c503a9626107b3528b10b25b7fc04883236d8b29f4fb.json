{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nexport class ScrollerShim {\n  constructor(element) {\n    this._node = null;\n    this._element = null;\n    const node = element !== null && element !== void 0 ? element : window;\n    this._node = node;\n    if (element) {\n      this._element = element;\n    }\n  }\n  get element() {\n    return this._element || document.scrollingElement || document.documentElement;\n  }\n  get scrollTop() {\n    return this.element.scrollTop || window.scrollY;\n  }\n  get scrollLeft() {\n    return this.element.scrollLeft || window.scrollX;\n  }\n  get scrollHeight() {\n    return this.element.scrollHeight;\n  }\n  get scrollWidth() {\n    return this.element.scrollWidth;\n  }\n  get viewportHeight() {\n    return this._element ? this._element.getBoundingClientRect().height : window.innerHeight;\n  }\n  get viewportWidth() {\n    return this._element ? this._element.getBoundingClientRect().width : window.innerWidth;\n  }\n  get maxScrollTop() {\n    return this.scrollHeight - this.viewportHeight;\n  }\n  get maxScrollLeft() {\n    return this.scrollWidth - this.viewportWidth;\n  }\n}\nexport class ScrollerController extends ScrollerShim {\n  constructor(client, element) {\n    super(element);\n    this._originalScrollTo = null;\n    this._originalScrollBy = null;\n    this._originalScroll = null;\n    this._clients = [];\n    this._retarget = null;\n    this._end = null;\n    this.__destination = null;\n    this.correctingScrollError = false;\n    const node = this._node;\n    const instance = ScrollerController._instanceMap.get(node);\n    if (instance) {\n      instance._attach(client);\n      return instance;\n    } else {\n      this._checkForArrival = this._checkForArrival.bind(this);\n      this._updateManagedScrollTo = this._updateManagedScrollTo.bind(this);\n      this.scrollTo = this.scrollTo.bind(this);\n      this.scrollBy = this.scrollBy.bind(this);\n      this._originalScrollTo = node.scrollTo;\n      this._originalScrollBy = node.scrollBy;\n      this._originalScroll = node.scroll;\n      this._attach(client);\n    }\n  }\n  get _destination() {\n    return this.__destination;\n  }\n  get scrolling() {\n    return this._destination !== null;\n  }\n  scrollTo(p1, p2) {\n    const options = typeof p1 === 'number' && typeof p2 === 'number' ? {\n      left: p1,\n      top: p2\n    } : p1;\n    this._scrollTo(options);\n  }\n  scrollBy(p1, p2) {\n    const options = typeof p1 === 'number' && typeof p2 === 'number' ? {\n      left: p1,\n      top: p2\n    } : p1;\n    if (options.top !== undefined) {\n      options.top += this.scrollTop;\n    }\n    if (options.left !== undefined) {\n      options.left += this.scrollLeft;\n    }\n    this._scrollTo(options);\n  }\n  _nativeScrollTo(options) {\n    this._originalScrollTo.bind(this._element || window)(options);\n  }\n  _scrollTo(options, retarget = null, end = null) {\n    if (this._end !== null) {\n      this._end();\n    }\n    if (options.behavior === 'smooth') {\n      this._setDestination(options);\n      this._retarget = retarget;\n      this._end = end;\n    } else {\n      this._resetScrollState();\n    }\n    this._nativeScrollTo(options);\n  }\n  _setDestination(options) {\n    let {\n      top,\n      left\n    } = options;\n    top = top === undefined ? undefined : Math.max(0, Math.min(top, this.maxScrollTop));\n    left = left === undefined ? undefined : Math.max(0, Math.min(left, this.maxScrollLeft));\n    if (this._destination !== null && left === this._destination.left && top === this._destination.top) {\n      return false;\n    }\n    this.__destination = {\n      top,\n      left,\n      behavior: 'smooth'\n    };\n    return true;\n  }\n  _resetScrollState() {\n    this.__destination = null;\n    this._retarget = null;\n    this._end = null;\n  }\n  _updateManagedScrollTo(coordinates) {\n    if (this._destination) {\n      if (this._setDestination(coordinates)) {\n        this._nativeScrollTo(this._destination);\n      }\n    }\n  }\n  managedScrollTo(options, retarget, end) {\n    this._scrollTo(options, retarget, end);\n    return this._updateManagedScrollTo;\n  }\n  correctScrollError(coordinates) {\n    this.correctingScrollError = true;\n    requestAnimationFrame(() => requestAnimationFrame(() => this.correctingScrollError = false));\n    // Correct the error\n    this._nativeScrollTo(coordinates);\n    // Then, if we were headed for a specific destination, we continue scrolling:\n    // First, we update our target destination, if applicable...\n    if (this._retarget) {\n      this._setDestination(this._retarget());\n    }\n    // Then we go ahead and resume scrolling\n    if (this._destination) {\n      this._nativeScrollTo(this._destination);\n    }\n  }\n  _checkForArrival() {\n    if (this._destination !== null) {\n      const {\n        scrollTop,\n        scrollLeft\n      } = this;\n      let {\n        top,\n        left\n      } = this._destination;\n      top = Math.min(top || 0, this.maxScrollTop);\n      left = Math.min(left || 0, this.maxScrollLeft);\n      const topDiff = Math.abs(top - scrollTop);\n      const leftDiff = Math.abs(left - scrollLeft);\n      // We check to see if we've arrived at our destination.\n      if (topDiff < 1 && leftDiff < 1) {\n        if (this._end) {\n          this._end();\n        }\n        this._resetScrollState();\n      }\n    }\n  }\n  detach(client) {\n    this._clients = this._clients.splice(this._clients.indexOf(client), 1);\n    if (this._clients.length === 0) {\n      this._node.scrollTo = this._originalScrollTo;\n      this._node.scrollBy = this._originalScrollBy;\n      this._node.scroll = this._originalScroll;\n      this._node.removeEventListener('scroll', this._checkForArrival);\n    }\n    return null;\n  }\n  _attach(client) {\n    this._clients.push(client);\n    if (this._clients.length === 1) {\n      this._node.scrollTo = this.scrollTo;\n      this._node.scrollBy = this.scrollBy;\n      this._node.scroll = this.scrollTo;\n      this._node.addEventListener('scroll', this._checkForArrival);\n    }\n  }\n}\nScrollerController._instanceMap = new WeakMap();","map":{"version":3,"names":["ScrollerShim","constructor","element","_node","_element","node","window","document","scrollingElement","documentElement","scrollTop","scrollY","scrollLeft","scrollX","scrollHeight","scrollWidth","viewportHeight","getBoundingClientRect","height","innerHeight","viewportWidth","width","innerWidth","maxScrollTop","maxScrollLeft","ScrollerController","client","_originalScrollTo","_originalScrollBy","_originalScroll","_clients","_retarget","_end","__destination","correctingScrollError","instance","_instanceMap","get","_attach","_checkForArrival","bind","_updateManagedScrollTo","scrollTo","scrollBy","scroll","_destination","scrolling","p1","p2","options","left","top","_scrollTo","undefined","_nativeScrollTo","retarget","end","behavior","_setDestination","_resetScrollState","Math","max","min","coordinates","managedScrollTo","correctScrollError","requestAnimationFrame","topDiff","abs","leftDiff","detach","splice","indexOf","length","removeEventListener","push","addEventListener","WeakMap"],"sources":["/Users/tima/kbtu/4thSemester/web/Lab4/angular/node_modules/@lit-labs/virtualizer/ScrollerController.js"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nexport class ScrollerShim {\n    constructor(element) {\n        this._node = null;\n        this._element = null;\n        const node = element !== null && element !== void 0 ? element : window;\n        this._node = node;\n        if (element) {\n            this._element = element;\n        }\n    }\n    get element() {\n        return (this._element || document.scrollingElement || document.documentElement);\n    }\n    get scrollTop() {\n        return this.element.scrollTop || window.scrollY;\n    }\n    get scrollLeft() {\n        return this.element.scrollLeft || window.scrollX;\n    }\n    get scrollHeight() {\n        return this.element.scrollHeight;\n    }\n    get scrollWidth() {\n        return this.element.scrollWidth;\n    }\n    get viewportHeight() {\n        return this._element\n            ? this._element.getBoundingClientRect().height\n            : window.innerHeight;\n    }\n    get viewportWidth() {\n        return this._element\n            ? this._element.getBoundingClientRect().width\n            : window.innerWidth;\n    }\n    get maxScrollTop() {\n        return this.scrollHeight - this.viewportHeight;\n    }\n    get maxScrollLeft() {\n        return this.scrollWidth - this.viewportWidth;\n    }\n}\nexport class ScrollerController extends ScrollerShim {\n    constructor(client, element) {\n        super(element);\n        this._originalScrollTo = null;\n        this._originalScrollBy = null;\n        this._originalScroll = null;\n        this._clients = [];\n        this._retarget = null;\n        this._end = null;\n        this.__destination = null;\n        this.correctingScrollError = false;\n        const node = this._node;\n        const instance = ScrollerController._instanceMap.get(node);\n        if (instance) {\n            instance._attach(client);\n            return instance;\n        }\n        else {\n            this._checkForArrival = this._checkForArrival.bind(this);\n            this._updateManagedScrollTo = this._updateManagedScrollTo.bind(this);\n            this.scrollTo = this.scrollTo.bind(this);\n            this.scrollBy = this.scrollBy.bind(this);\n            this._originalScrollTo = node.scrollTo;\n            this._originalScrollBy = node.scrollBy;\n            this._originalScroll = node.scroll;\n            this._attach(client);\n        }\n    }\n    get _destination() {\n        return this.__destination;\n    }\n    get scrolling() {\n        return this._destination !== null;\n    }\n    scrollTo(p1, p2) {\n        const options = typeof p1 === 'number' && typeof p2 === 'number'\n            ? { left: p1, top: p2 }\n            : p1;\n        this._scrollTo(options);\n    }\n    scrollBy(p1, p2) {\n        const options = typeof p1 === 'number' && typeof p2 === 'number'\n            ? { left: p1, top: p2 }\n            : p1;\n        if (options.top !== undefined) {\n            options.top += this.scrollTop;\n        }\n        if (options.left !== undefined) {\n            options.left += this.scrollLeft;\n        }\n        this._scrollTo(options);\n    }\n    _nativeScrollTo(options) {\n        this._originalScrollTo.bind(this._element || window)(options);\n    }\n    _scrollTo(options, retarget = null, end = null) {\n        if (this._end !== null) {\n            this._end();\n        }\n        if (options.behavior === 'smooth') {\n            this._setDestination(options);\n            this._retarget = retarget;\n            this._end = end;\n        }\n        else {\n            this._resetScrollState();\n        }\n        this._nativeScrollTo(options);\n    }\n    _setDestination(options) {\n        let { top, left } = options;\n        top =\n            top === undefined\n                ? undefined\n                : Math.max(0, Math.min(top, this.maxScrollTop));\n        left =\n            left === undefined\n                ? undefined\n                : Math.max(0, Math.min(left, this.maxScrollLeft));\n        if (this._destination !== null &&\n            left === this._destination.left &&\n            top === this._destination.top) {\n            return false;\n        }\n        this.__destination = { top, left, behavior: 'smooth' };\n        return true;\n    }\n    _resetScrollState() {\n        this.__destination = null;\n        this._retarget = null;\n        this._end = null;\n    }\n    _updateManagedScrollTo(coordinates) {\n        if (this._destination) {\n            if (this._setDestination(coordinates)) {\n                this._nativeScrollTo(this._destination);\n            }\n        }\n    }\n    managedScrollTo(options, retarget, end) {\n        this._scrollTo(options, retarget, end);\n        return this._updateManagedScrollTo;\n    }\n    correctScrollError(coordinates) {\n        this.correctingScrollError = true;\n        requestAnimationFrame(() => requestAnimationFrame(() => (this.correctingScrollError = false)));\n        // Correct the error\n        this._nativeScrollTo(coordinates);\n        // Then, if we were headed for a specific destination, we continue scrolling:\n        // First, we update our target destination, if applicable...\n        if (this._retarget) {\n            this._setDestination(this._retarget());\n        }\n        // Then we go ahead and resume scrolling\n        if (this._destination) {\n            this._nativeScrollTo(this._destination);\n        }\n    }\n    _checkForArrival() {\n        if (this._destination !== null) {\n            const { scrollTop, scrollLeft } = this;\n            let { top, left } = this._destination;\n            top = Math.min(top || 0, this.maxScrollTop);\n            left = Math.min(left || 0, this.maxScrollLeft);\n            const topDiff = Math.abs(top - scrollTop);\n            const leftDiff = Math.abs(left - scrollLeft);\n            // We check to see if we've arrived at our destination.\n            if (topDiff < 1 && leftDiff < 1) {\n                if (this._end) {\n                    this._end();\n                }\n                this._resetScrollState();\n            }\n        }\n    }\n    detach(client) {\n        this._clients = this._clients.splice(this._clients.indexOf(client), 1);\n        if (this._clients.length === 0) {\n            this._node.scrollTo = this._originalScrollTo;\n            this._node.scrollBy = this._originalScrollBy;\n            this._node.scroll = this._originalScroll;\n            this._node.removeEventListener('scroll', this._checkForArrival);\n        }\n        return null;\n    }\n    _attach(client) {\n        this._clients.push(client);\n        if (this._clients.length === 1) {\n            this._node.scrollTo = this.scrollTo;\n            this._node.scrollBy = this.scrollBy;\n            this._node.scroll = this.scrollTo;\n            this._node.addEventListener('scroll', this._checkForArrival);\n        }\n    }\n}\nScrollerController._instanceMap = new WeakMap();\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}