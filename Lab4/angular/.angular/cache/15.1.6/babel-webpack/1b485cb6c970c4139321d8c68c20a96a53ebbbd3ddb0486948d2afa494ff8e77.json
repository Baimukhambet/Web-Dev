{"ast":null,"code":"import _asyncToGenerator from \"/Users/tima/kbtu/4thSemester/web/Lab4/angular/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport EventTarget from '../../polyfillLoaders/EventTarget.js';\nexport function dim1(direction) {\n  return direction === 'horizontal' ? 'width' : 'height';\n}\nexport function dim2(direction) {\n  return direction === 'horizontal' ? 'height' : 'width';\n}\nexport function pos1(direction) {\n  return direction === 'horizontal' ? 'left' : 'top';\n}\nexport function pos2(direction) {\n  return direction === 'horizontal' ? 'top' : 'left';\n}\nexport class BaseLayout {\n  constructor(config) {\n    /**\n     * The last set viewport scroll position.\n     */\n    this._latestCoords = {\n      left: 0,\n      top: 0\n    };\n    /**\n     * Scrolling direction.\n     */\n    this._direction = null;\n    /**\n     * Dimensions of the viewport.\n     */\n    this._viewportSize = {\n      width: 0,\n      height: 0\n    };\n    this.totalScrollSize = {\n      width: 0,\n      height: 0\n    };\n    this.offsetWithinScroller = {\n      left: 0,\n      top: 0\n    };\n    /**\n     * Flag for debouncing asynchnronous reflow requests.\n     */\n    this._pendingReflow = false;\n    this._pendingLayoutUpdate = false;\n    this._pin = null;\n    /**\n     * The index of the first item intersecting the viewport.\n     */\n    this._firstVisible = 0;\n    /**\n     * The index of the last item intersecting the viewport.\n     */\n    this._lastVisible = 0;\n    this._eventTargetPromise = EventTarget().then(Ctor => {\n      this._eventTarget = new Ctor();\n    });\n    /**\n     * Pixel offset in the scroll direction of the first child.\n     */\n    this._physicalMin = 0;\n    /**\n     * Pixel offset in the scroll direction of the last child.\n     */\n    this._physicalMax = 0;\n    /**\n     * Index of the first child.\n     */\n    this._first = -1;\n    /**\n     * Index of the last child.\n     */\n    this._last = -1;\n    /**\n     * Length in the scrolling direction.\n     */\n    this._sizeDim = 'height';\n    /**\n     * Length in the non-scrolling direction.\n     */\n    this._secondarySizeDim = 'width';\n    /**\n     * Position in the scrolling direction.\n     */\n    this._positionDim = 'top';\n    /**\n     * Position in the non-scrolling direction.\n     */\n    this._secondaryPositionDim = 'left';\n    /**\n     * Current scroll offset in pixels.\n     */\n    this._scrollPosition = 0;\n    /**\n     * Difference between current scroll offset and scroll offset calculated due\n     * to a reflow.\n     */\n    this._scrollError = 0;\n    /**\n     * Total number of items that could possibly be displayed. Used to help\n     * calculate the scroll size.\n     */\n    this._items = [];\n    /**\n     * The total (estimated) length of all items in the scrolling direction.\n     */\n    this._scrollSize = 1;\n    /**\n     * Number of pixels beyond the viewport to still include\n     * in the active range of items.\n     */\n    // TODO (graynorton): Probably want to make this something we calculate based\n    // on viewport size, item size, other factors, possibly still with a dial of some kind\n    this._overhang = 1000;\n    this._eventTarget = null;\n    // Delay setting config so that subclasses do setup work first\n    Promise.resolve().then(() => this.config = config || this._defaultConfig);\n  }\n  get _defaultConfig() {\n    return {\n      direction: 'vertical'\n    };\n  }\n  set config(config) {\n    Object.assign(this, Object.assign({}, this._defaultConfig, config));\n  }\n  get config() {\n    return {\n      direction: this.direction\n    };\n  }\n  /**\n   * Maximum index of children + 1, to help estimate total height of the scroll\n   * space.\n   */\n  get items() {\n    return this._items;\n  }\n  set items(items) {\n    if (items !== this._items) {\n      this._items = items;\n      this._scheduleReflow();\n    }\n  }\n  /**\n   * Primary scrolling direction.\n   */\n  get direction() {\n    return this._direction;\n  }\n  set direction(dir) {\n    // Force it to be either horizontal or vertical.\n    dir = dir === 'horizontal' ? dir : 'vertical';\n    if (dir !== this._direction) {\n      this._direction = dir;\n      this._sizeDim = dir === 'horizontal' ? 'width' : 'height';\n      this._secondarySizeDim = dir === 'horizontal' ? 'height' : 'width';\n      this._positionDim = dir === 'horizontal' ? 'left' : 'top';\n      this._secondaryPositionDim = dir === 'horizontal' ? 'top' : 'left';\n      this._triggerReflow();\n    }\n  }\n  /**\n   * Height and width of the viewport.\n   */\n  get viewportSize() {\n    return this._viewportSize;\n  }\n  set viewportSize(dims) {\n    const {\n      _viewDim1,\n      _viewDim2\n    } = this;\n    Object.assign(this._viewportSize, dims);\n    if (_viewDim2 !== this._viewDim2) {\n      // this._viewDim2Changed();\n      this._scheduleLayoutUpdate();\n    } else if (_viewDim1 !== this._viewDim1) {\n      this._checkThresholds();\n    }\n  }\n  /**\n   * Scroll offset of the viewport.\n   */\n  get viewportScroll() {\n    return this._latestCoords;\n  }\n  set viewportScroll(coords) {\n    Object.assign(this._latestCoords, coords);\n    const oldPos = this._scrollPosition;\n    this._scrollPosition = this._latestCoords[this._positionDim];\n    const change = Math.abs(oldPos - this._scrollPosition);\n    if (change >= 1) {\n      this._updateVisibleIndices({\n        emit: true\n      });\n    }\n    this._checkThresholds();\n  }\n  /**\n   * Perform a reflow if one has been scheduled.\n   */\n  reflowIfNeeded(force = false) {\n    if (force || this._pendingReflow) {\n      this._pendingReflow = false;\n      this._reflow();\n    }\n  }\n  set pin(options) {\n    this._pin = options;\n    this._triggerReflow();\n  }\n  get pin() {\n    if (this._pin !== null) {\n      const {\n        index,\n        block\n      } = this._pin;\n      return {\n        index: Math.max(0, Math.min(index, this.items.length - 1)),\n        block\n      };\n    }\n    return null;\n  }\n  _clampScrollPosition(val) {\n    return Math.max(-this.offsetWithinScroller[this._positionDim], Math.min(val, this.totalScrollSize[dim1(this.direction)] - this._viewDim1));\n  }\n  unpin() {\n    if (this._pin !== null) {\n      this._emitUnpinned();\n      this._pin = null;\n    }\n  }\n  dispatchEvent(evt) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      yield _this._eventTargetPromise;\n      _this._eventTarget.dispatchEvent(evt);\n    })();\n  }\n  addEventListener(type, listener, options) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      yield _this2._eventTargetPromise;\n      _this2._eventTarget.addEventListener(type, listener, options);\n    })();\n  }\n  removeEventListener(type, callback, options) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      yield _this3._eventTargetPromise;\n      _this3._eventTarget.removeEventListener(type, callback, options);\n    })();\n  }\n  _updateLayout() {\n    // Override\n  }\n  // protected _viewDim2Changed(): void {\n  //   this._scheduleLayoutUpdate();\n  // }\n  /**\n   * The height or width of the viewport, whichever corresponds to the scrolling direction.\n   */\n  get _viewDim1() {\n    return this._viewportSize[this._sizeDim];\n  }\n  /**\n   * The height or width of the viewport, whichever does NOT correspond to the scrolling direction.\n   */\n  get _viewDim2() {\n    return this._viewportSize[this._secondarySizeDim];\n  }\n  _scheduleReflow() {\n    this._pendingReflow = true;\n  }\n  _scheduleLayoutUpdate() {\n    this._pendingLayoutUpdate = true;\n    this._scheduleReflow();\n  }\n  // For triggering a reflow based on incoming changes to\n  // the layout config.\n  _triggerReflow() {\n    this._scheduleLayoutUpdate();\n    // TODO graynorton@: reflowIfNeeded() isn't really supposed\n    // to be called internally. Address in larger cleanup\n    // of virtualizer / layout interaction pattern.\n    // this.reflowIfNeeded(true);\n    Promise.resolve().then(() => this.reflowIfNeeded());\n  }\n  _reflow() {\n    if (this._pendingLayoutUpdate) {\n      this._updateLayout();\n      this._pendingLayoutUpdate = false;\n    }\n    this._updateScrollSize();\n    this._setPositionFromPin();\n    this._getActiveItems();\n    this._updateVisibleIndices();\n    this._emitScrollSize();\n    this._emitRange();\n    this._emitChildPositions();\n    this._emitScrollError();\n  }\n  /**\n   * If we are supposed to be pinned to a particular\n   * item or set of coordinates, we set `_scrollPosition`\n   * accordingly and adjust `_scrollError` as needed\n   * so that the virtualizer can keep the scroll\n   * position in the DOM in sync\n   */\n  _setPositionFromPin() {\n    if (this.pin !== null) {\n      const lastScrollPosition = this._scrollPosition;\n      const {\n        index,\n        block\n      } = this.pin;\n      this._scrollPosition = this._calculateScrollIntoViewPosition({\n        index,\n        block: block || 'start'\n      }) - this.offsetWithinScroller[this._positionDim];\n      this._scrollError = lastScrollPosition - this._scrollPosition;\n    }\n  }\n  /**\n   * Calculate the coordinates to scroll to, given\n   * a request to scroll to the element at a specific\n   * index.\n   *\n   * Supports the same positioning options (`start`,\n   * `center`, `end`, `nearest`) as the standard\n   * `Element.scrollIntoView()` method, but currently\n   * only considers the provided value in the `block`\n   * dimension, since we don't yet have any layouts\n   * that support virtualization in two dimensions.\n   */\n  _calculateScrollIntoViewPosition(options) {\n    const {\n      block\n    } = options;\n    const index = Math.min(this.items.length, Math.max(0, options.index));\n    const itemStartPosition = this._getItemPosition(index)[this._positionDim];\n    let scrollPosition = itemStartPosition;\n    if (block !== 'start') {\n      const itemSize = this._getItemSize(index)[this._sizeDim];\n      if (block === 'center') {\n        scrollPosition = itemStartPosition - 0.5 * this._viewDim1 + 0.5 * itemSize;\n      } else {\n        const itemEndPosition = itemStartPosition - this._viewDim1 + itemSize;\n        if (block === 'end') {\n          scrollPosition = itemEndPosition;\n        } else {\n          // block === 'nearest'\n          const currentScrollPosition = this._scrollPosition;\n          scrollPosition = Math.abs(currentScrollPosition - itemStartPosition) < Math.abs(currentScrollPosition - itemEndPosition) ? itemStartPosition : itemEndPosition;\n        }\n      }\n    }\n    scrollPosition += this.offsetWithinScroller[this._positionDim];\n    return this._clampScrollPosition(scrollPosition);\n  }\n  getScrollIntoViewCoordinates(options) {\n    return {\n      [this._positionDim]: this._calculateScrollIntoViewPosition(options)\n    };\n  }\n  _emitUnpinned() {\n    this.dispatchEvent(new CustomEvent('unpinned'));\n  }\n  _emitRange() {\n    const detail = {\n      first: this._first,\n      last: this._last,\n      firstVisible: this._firstVisible,\n      lastVisible: this._lastVisible\n    };\n    this.dispatchEvent(new CustomEvent('rangechange', {\n      detail\n    }));\n  }\n  _emitScrollSize() {\n    const detail = {\n      [this._sizeDim]: this._scrollSize,\n      [this._secondarySizeDim]: null\n    };\n    this.dispatchEvent(new CustomEvent('scrollsizechange', {\n      detail\n    }));\n  }\n  _emitScrollError() {\n    if (this._scrollError) {\n      const detail = {\n        [this._positionDim]: this._scrollError,\n        [this._secondaryPositionDim]: 0\n      };\n      this.dispatchEvent(new CustomEvent('scrollerrorchange', {\n        detail\n      }));\n      this._scrollError = 0;\n    }\n  }\n  /**\n   * Get or estimate the top and left positions of items in the current range.\n   * Emit an itempositionchange event with these positions.\n   */\n  _emitChildPositions() {\n    if (this._first !== -1 && this._last !== -1) {\n      const detail = new Map();\n      for (let idx = this._first; idx <= this._last; idx++) {\n        detail.set(idx, this._getItemPosition(idx));\n      }\n      this.dispatchEvent(new CustomEvent('itempositionchange', {\n        detail\n      }));\n    }\n  }\n  /**\n   * Number of items to display.\n   */\n  get _num() {\n    if (this._first === -1 || this._last === -1) {\n      return 0;\n    }\n    return this._last - this._first + 1;\n  }\n  _checkThresholds() {\n    if (this._viewDim1 === 0 && this._num > 0 || this._pin !== null) {\n      this._scheduleReflow();\n    } else {\n      const min = Math.max(0, this._scrollPosition - this._overhang);\n      const max = Math.min(this._scrollSize, this._scrollPosition + this._viewDim1 + this._overhang);\n      if (this._physicalMin > min || this._physicalMax < max) {\n        this._scheduleReflow();\n      }\n    }\n  }\n  /**\n   * Find the indices of the first and last items to intersect the viewport.\n   * Emit a visibleindiceschange event when either index changes.\n   */\n  _updateVisibleIndices(options) {\n    if (this._first === -1 || this._last === -1) return;\n    let firstVisible = this._first;\n    while (firstVisible < this._last && Math.round(this._getItemPosition(firstVisible)[this._positionDim] + this._getItemSize(firstVisible)[this._sizeDim]) <= Math.round(this._scrollPosition)) {\n      firstVisible++;\n    }\n    let lastVisible = this._last;\n    while (lastVisible > this._first && Math.round(this._getItemPosition(lastVisible)[this._positionDim]) >= Math.round(this._scrollPosition + this._viewDim1)) {\n      lastVisible--;\n    }\n    if (firstVisible !== this._firstVisible || lastVisible !== this._lastVisible) {\n      this._firstVisible = firstVisible;\n      this._lastVisible = lastVisible;\n      if (options && options.emit) {\n        this._emitRange();\n      }\n    }\n  }\n}","map":{"version":3,"names":["EventTarget","dim1","direction","dim2","pos1","pos2","BaseLayout","constructor","config","_latestCoords","left","top","_direction","_viewportSize","width","height","totalScrollSize","offsetWithinScroller","_pendingReflow","_pendingLayoutUpdate","_pin","_firstVisible","_lastVisible","_eventTargetPromise","then","Ctor","_eventTarget","_physicalMin","_physicalMax","_first","_last","_sizeDim","_secondarySizeDim","_positionDim","_secondaryPositionDim","_scrollPosition","_scrollError","_items","_scrollSize","_overhang","Promise","resolve","_defaultConfig","Object","assign","items","_scheduleReflow","dir","_triggerReflow","viewportSize","dims","_viewDim1","_viewDim2","_scheduleLayoutUpdate","_checkThresholds","viewportScroll","coords","oldPos","change","Math","abs","_updateVisibleIndices","emit","reflowIfNeeded","force","_reflow","pin","options","index","block","max","min","length","_clampScrollPosition","val","unpin","_emitUnpinned","dispatchEvent","evt","addEventListener","type","listener","removeEventListener","callback","_updateLayout","_updateScrollSize","_setPositionFromPin","_getActiveItems","_emitScrollSize","_emitRange","_emitChildPositions","_emitScrollError","lastScrollPosition","_calculateScrollIntoViewPosition","itemStartPosition","_getItemPosition","scrollPosition","itemSize","_getItemSize","itemEndPosition","currentScrollPosition","getScrollIntoViewCoordinates","CustomEvent","detail","first","last","firstVisible","lastVisible","Map","idx","set","_num","round"],"sources":["/Users/tima/kbtu/4thSemester/web/Lab4/angular/node_modules/@lit-labs/virtualizer/layouts/shared/BaseLayout.js"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport EventTarget from '../../polyfillLoaders/EventTarget.js';\nexport function dim1(direction) {\n    return direction === 'horizontal' ? 'width' : 'height';\n}\nexport function dim2(direction) {\n    return direction === 'horizontal' ? 'height' : 'width';\n}\nexport function pos1(direction) {\n    return direction === 'horizontal' ? 'left' : 'top';\n}\nexport function pos2(direction) {\n    return direction === 'horizontal' ? 'top' : 'left';\n}\nexport class BaseLayout {\n    constructor(config) {\n        /**\n         * The last set viewport scroll position.\n         */\n        this._latestCoords = { left: 0, top: 0 };\n        /**\n         * Scrolling direction.\n         */\n        this._direction = null;\n        /**\n         * Dimensions of the viewport.\n         */\n        this._viewportSize = { width: 0, height: 0 };\n        this.totalScrollSize = { width: 0, height: 0 };\n        this.offsetWithinScroller = { left: 0, top: 0 };\n        /**\n         * Flag for debouncing asynchnronous reflow requests.\n         */\n        this._pendingReflow = false;\n        this._pendingLayoutUpdate = false;\n        this._pin = null;\n        /**\n         * The index of the first item intersecting the viewport.\n         */\n        this._firstVisible = 0;\n        /**\n         * The index of the last item intersecting the viewport.\n         */\n        this._lastVisible = 0;\n        this._eventTargetPromise = EventTarget().then((Ctor) => {\n            this._eventTarget = new Ctor();\n        });\n        /**\n         * Pixel offset in the scroll direction of the first child.\n         */\n        this._physicalMin = 0;\n        /**\n         * Pixel offset in the scroll direction of the last child.\n         */\n        this._physicalMax = 0;\n        /**\n         * Index of the first child.\n         */\n        this._first = -1;\n        /**\n         * Index of the last child.\n         */\n        this._last = -1;\n        /**\n         * Length in the scrolling direction.\n         */\n        this._sizeDim = 'height';\n        /**\n         * Length in the non-scrolling direction.\n         */\n        this._secondarySizeDim = 'width';\n        /**\n         * Position in the scrolling direction.\n         */\n        this._positionDim = 'top';\n        /**\n         * Position in the non-scrolling direction.\n         */\n        this._secondaryPositionDim = 'left';\n        /**\n         * Current scroll offset in pixels.\n         */\n        this._scrollPosition = 0;\n        /**\n         * Difference between current scroll offset and scroll offset calculated due\n         * to a reflow.\n         */\n        this._scrollError = 0;\n        /**\n         * Total number of items that could possibly be displayed. Used to help\n         * calculate the scroll size.\n         */\n        this._items = [];\n        /**\n         * The total (estimated) length of all items in the scrolling direction.\n         */\n        this._scrollSize = 1;\n        /**\n         * Number of pixels beyond the viewport to still include\n         * in the active range of items.\n         */\n        // TODO (graynorton): Probably want to make this something we calculate based\n        // on viewport size, item size, other factors, possibly still with a dial of some kind\n        this._overhang = 1000;\n        this._eventTarget = null;\n        // Delay setting config so that subclasses do setup work first\n        Promise.resolve().then(() => (this.config = config || this._defaultConfig));\n    }\n    get _defaultConfig() {\n        return {\n            direction: 'vertical',\n        };\n    }\n    set config(config) {\n        Object.assign(this, Object.assign({}, this._defaultConfig, config));\n    }\n    get config() {\n        return {\n            direction: this.direction,\n        };\n    }\n    /**\n     * Maximum index of children + 1, to help estimate total height of the scroll\n     * space.\n     */\n    get items() {\n        return this._items;\n    }\n    set items(items) {\n        if (items !== this._items) {\n            this._items = items;\n            this._scheduleReflow();\n        }\n    }\n    /**\n     * Primary scrolling direction.\n     */\n    get direction() {\n        return this._direction;\n    }\n    set direction(dir) {\n        // Force it to be either horizontal or vertical.\n        dir = dir === 'horizontal' ? dir : 'vertical';\n        if (dir !== this._direction) {\n            this._direction = dir;\n            this._sizeDim = dir === 'horizontal' ? 'width' : 'height';\n            this._secondarySizeDim = dir === 'horizontal' ? 'height' : 'width';\n            this._positionDim = dir === 'horizontal' ? 'left' : 'top';\n            this._secondaryPositionDim = dir === 'horizontal' ? 'top' : 'left';\n            this._triggerReflow();\n        }\n    }\n    /**\n     * Height and width of the viewport.\n     */\n    get viewportSize() {\n        return this._viewportSize;\n    }\n    set viewportSize(dims) {\n        const { _viewDim1, _viewDim2 } = this;\n        Object.assign(this._viewportSize, dims);\n        if (_viewDim2 !== this._viewDim2) {\n            // this._viewDim2Changed();\n            this._scheduleLayoutUpdate();\n        }\n        else if (_viewDim1 !== this._viewDim1) {\n            this._checkThresholds();\n        }\n    }\n    /**\n     * Scroll offset of the viewport.\n     */\n    get viewportScroll() {\n        return this._latestCoords;\n    }\n    set viewportScroll(coords) {\n        Object.assign(this._latestCoords, coords);\n        const oldPos = this._scrollPosition;\n        this._scrollPosition = this._latestCoords[this._positionDim];\n        const change = Math.abs(oldPos - this._scrollPosition);\n        if (change >= 1) {\n            this._updateVisibleIndices({ emit: true });\n        }\n        this._checkThresholds();\n    }\n    /**\n     * Perform a reflow if one has been scheduled.\n     */\n    reflowIfNeeded(force = false) {\n        if (force || this._pendingReflow) {\n            this._pendingReflow = false;\n            this._reflow();\n        }\n    }\n    set pin(options) {\n        this._pin = options;\n        this._triggerReflow();\n    }\n    get pin() {\n        if (this._pin !== null) {\n            const { index, block } = this._pin;\n            return {\n                index: Math.max(0, Math.min(index, this.items.length - 1)),\n                block,\n            };\n        }\n        return null;\n    }\n    _clampScrollPosition(val) {\n        return Math.max(-this.offsetWithinScroller[this._positionDim], Math.min(val, this.totalScrollSize[dim1(this.direction)] - this._viewDim1));\n    }\n    unpin() {\n        if (this._pin !== null) {\n            this._emitUnpinned();\n            this._pin = null;\n        }\n    }\n    async dispatchEvent(evt) {\n        await this._eventTargetPromise;\n        this._eventTarget.dispatchEvent(evt);\n    }\n    async addEventListener(type, listener, options) {\n        await this._eventTargetPromise;\n        this._eventTarget.addEventListener(type, listener, options);\n    }\n    async removeEventListener(type, callback, options) {\n        await this._eventTargetPromise;\n        this._eventTarget.removeEventListener(type, callback, options);\n    }\n    _updateLayout() {\n        // Override\n    }\n    // protected _viewDim2Changed(): void {\n    //   this._scheduleLayoutUpdate();\n    // }\n    /**\n     * The height or width of the viewport, whichever corresponds to the scrolling direction.\n     */\n    get _viewDim1() {\n        return this._viewportSize[this._sizeDim];\n    }\n    /**\n     * The height or width of the viewport, whichever does NOT correspond to the scrolling direction.\n     */\n    get _viewDim2() {\n        return this._viewportSize[this._secondarySizeDim];\n    }\n    _scheduleReflow() {\n        this._pendingReflow = true;\n    }\n    _scheduleLayoutUpdate() {\n        this._pendingLayoutUpdate = true;\n        this._scheduleReflow();\n    }\n    // For triggering a reflow based on incoming changes to\n    // the layout config.\n    _triggerReflow() {\n        this._scheduleLayoutUpdate();\n        // TODO graynorton@: reflowIfNeeded() isn't really supposed\n        // to be called internally. Address in larger cleanup\n        // of virtualizer / layout interaction pattern.\n        // this.reflowIfNeeded(true);\n        Promise.resolve().then(() => this.reflowIfNeeded());\n    }\n    _reflow() {\n        if (this._pendingLayoutUpdate) {\n            this._updateLayout();\n            this._pendingLayoutUpdate = false;\n        }\n        this._updateScrollSize();\n        this._setPositionFromPin();\n        this._getActiveItems();\n        this._updateVisibleIndices();\n        this._emitScrollSize();\n        this._emitRange();\n        this._emitChildPositions();\n        this._emitScrollError();\n    }\n    /**\n     * If we are supposed to be pinned to a particular\n     * item or set of coordinates, we set `_scrollPosition`\n     * accordingly and adjust `_scrollError` as needed\n     * so that the virtualizer can keep the scroll\n     * position in the DOM in sync\n     */\n    _setPositionFromPin() {\n        if (this.pin !== null) {\n            const lastScrollPosition = this._scrollPosition;\n            const { index, block } = this.pin;\n            this._scrollPosition =\n                this._calculateScrollIntoViewPosition({\n                    index,\n                    block: block || 'start',\n                }) - this.offsetWithinScroller[this._positionDim];\n            this._scrollError = lastScrollPosition - this._scrollPosition;\n        }\n    }\n    /**\n     * Calculate the coordinates to scroll to, given\n     * a request to scroll to the element at a specific\n     * index.\n     *\n     * Supports the same positioning options (`start`,\n     * `center`, `end`, `nearest`) as the standard\n     * `Element.scrollIntoView()` method, but currently\n     * only considers the provided value in the `block`\n     * dimension, since we don't yet have any layouts\n     * that support virtualization in two dimensions.\n     */\n    _calculateScrollIntoViewPosition(options) {\n        const { block } = options;\n        const index = Math.min(this.items.length, Math.max(0, options.index));\n        const itemStartPosition = this._getItemPosition(index)[this._positionDim];\n        let scrollPosition = itemStartPosition;\n        if (block !== 'start') {\n            const itemSize = this._getItemSize(index)[this._sizeDim];\n            if (block === 'center') {\n                scrollPosition =\n                    itemStartPosition - 0.5 * this._viewDim1 + 0.5 * itemSize;\n            }\n            else {\n                const itemEndPosition = itemStartPosition - this._viewDim1 + itemSize;\n                if (block === 'end') {\n                    scrollPosition = itemEndPosition;\n                }\n                else {\n                    // block === 'nearest'\n                    const currentScrollPosition = this._scrollPosition;\n                    scrollPosition =\n                        Math.abs(currentScrollPosition - itemStartPosition) <\n                            Math.abs(currentScrollPosition - itemEndPosition)\n                            ? itemStartPosition\n                            : itemEndPosition;\n                }\n            }\n        }\n        scrollPosition += this.offsetWithinScroller[this._positionDim];\n        return this._clampScrollPosition(scrollPosition);\n    }\n    getScrollIntoViewCoordinates(options) {\n        return {\n            [this._positionDim]: this._calculateScrollIntoViewPosition(options),\n        };\n    }\n    _emitUnpinned() {\n        this.dispatchEvent(new CustomEvent('unpinned'));\n    }\n    _emitRange() {\n        const detail = {\n            first: this._first,\n            last: this._last,\n            firstVisible: this._firstVisible,\n            lastVisible: this._lastVisible,\n        };\n        this.dispatchEvent(new CustomEvent('rangechange', { detail }));\n    }\n    _emitScrollSize() {\n        const detail = {\n            [this._sizeDim]: this._scrollSize,\n            [this._secondarySizeDim]: null,\n        };\n        this.dispatchEvent(new CustomEvent('scrollsizechange', { detail }));\n    }\n    _emitScrollError() {\n        if (this._scrollError) {\n            const detail = {\n                [this._positionDim]: this._scrollError,\n                [this._secondaryPositionDim]: 0,\n            };\n            this.dispatchEvent(new CustomEvent('scrollerrorchange', { detail }));\n            this._scrollError = 0;\n        }\n    }\n    /**\n     * Get or estimate the top and left positions of items in the current range.\n     * Emit an itempositionchange event with these positions.\n     */\n    _emitChildPositions() {\n        if (this._first !== -1 && this._last !== -1) {\n            const detail = new Map();\n            for (let idx = this._first; idx <= this._last; idx++) {\n                detail.set(idx, this._getItemPosition(idx));\n            }\n            this.dispatchEvent(new CustomEvent('itempositionchange', { detail }));\n        }\n    }\n    /**\n     * Number of items to display.\n     */\n    get _num() {\n        if (this._first === -1 || this._last === -1) {\n            return 0;\n        }\n        return this._last - this._first + 1;\n    }\n    _checkThresholds() {\n        if ((this._viewDim1 === 0 && this._num > 0) || this._pin !== null) {\n            this._scheduleReflow();\n        }\n        else {\n            const min = Math.max(0, this._scrollPosition - this._overhang);\n            const max = Math.min(this._scrollSize, this._scrollPosition + this._viewDim1 + this._overhang);\n            if (this._physicalMin > min || this._physicalMax < max) {\n                this._scheduleReflow();\n            }\n        }\n    }\n    /**\n     * Find the indices of the first and last items to intersect the viewport.\n     * Emit a visibleindiceschange event when either index changes.\n     */\n    _updateVisibleIndices(options) {\n        if (this._first === -1 || this._last === -1)\n            return;\n        let firstVisible = this._first;\n        while (firstVisible < this._last &&\n            Math.round(this._getItemPosition(firstVisible)[this._positionDim] +\n                this._getItemSize(firstVisible)[this._sizeDim]) <= Math.round(this._scrollPosition)) {\n            firstVisible++;\n        }\n        let lastVisible = this._last;\n        while (lastVisible > this._first &&\n            Math.round(this._getItemPosition(lastVisible)[this._positionDim]) >=\n                Math.round(this._scrollPosition + this._viewDim1)) {\n            lastVisible--;\n        }\n        if (firstVisible !== this._firstVisible ||\n            lastVisible !== this._lastVisible) {\n            this._firstVisible = firstVisible;\n            this._lastVisible = lastVisible;\n            if (options && options.emit) {\n                this._emitRange();\n            }\n        }\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}