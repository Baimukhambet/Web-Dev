{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { noChange } from '../lit-html.js';\nimport { directive, Directive } from '../directive.js';\n// A sentinal that indicates guard() hasn't rendered anything yet\nconst initialValue = {};\nclass GuardDirective extends Directive {\n  constructor() {\n    super(...arguments);\n    this._previousValue = initialValue;\n  }\n  render(_value, f) {\n    return f();\n  }\n  update(_part, [value, f]) {\n    if (Array.isArray(value)) {\n      // Dirty-check arrays by item\n      if (Array.isArray(this._previousValue) && this._previousValue.length === value.length && value.every((v, i) => v === this._previousValue[i])) {\n        return noChange;\n      }\n    } else if (this._previousValue === value) {\n      // Dirty-check non-arrays by identity\n      return noChange;\n    }\n    // Copy the value if it's an array so that if it's mutated we don't forget\n    // what the previous values were.\n    this._previousValue = Array.isArray(value) ? Array.from(value) : value;\n    const r = this.render(value, f);\n    return r;\n  }\n}\n/**\n * Prevents re-render of a template function until a single value or an array of\n * values changes.\n *\n * Values are checked against previous values with strict equality (`===`), and\n * so the check won't detect nested property changes inside objects or arrays.\n * Arrays values have each item checked against the previous value at the same\n * index with strict equality. Nested arrays are also checked only by strict\n * equality.\n *\n * Example:\n *\n * ```js\n * html`\n *   <div>\n *     ${guard([user.id, company.id], () => html`...`)}\n *   </div>\n * `\n * ```\n *\n * In this case, the template only rerenders if either `user.id` or `company.id`\n * changes.\n *\n * guard() is useful with immutable data patterns, by preventing expensive work\n * until data updates.\n *\n * Example:\n *\n * ```js\n * html`\n *   <div>\n *     ${guard([immutableItems], () => immutableItems.map(i => html`${i}`))}\n *   </div>\n * `\n * ```\n *\n * In this case, items are mapped over only when the array reference changes.\n *\n * @param value the value to check before re-rendering\n * @param f the template function\n */\nexport const guard = directive(GuardDirective);","map":{"version":3,"names":["noChange","directive","Directive","initialValue","GuardDirective","constructor","arguments","_previousValue","render","_value","f","update","_part","value","Array","isArray","length","every","v","i","from","r","guard"],"sources":["/Users/tima/kbtu/4thSemester/web/Lab4/angular/node_modules/lit-html/development/directives/guard.js"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { noChange } from '../lit-html.js';\nimport { directive, Directive } from '../directive.js';\n// A sentinal that indicates guard() hasn't rendered anything yet\nconst initialValue = {};\nclass GuardDirective extends Directive {\n    constructor() {\n        super(...arguments);\n        this._previousValue = initialValue;\n    }\n    render(_value, f) {\n        return f();\n    }\n    update(_part, [value, f]) {\n        if (Array.isArray(value)) {\n            // Dirty-check arrays by item\n            if (Array.isArray(this._previousValue) &&\n                this._previousValue.length === value.length &&\n                value.every((v, i) => v === this._previousValue[i])) {\n                return noChange;\n            }\n        }\n        else if (this._previousValue === value) {\n            // Dirty-check non-arrays by identity\n            return noChange;\n        }\n        // Copy the value if it's an array so that if it's mutated we don't forget\n        // what the previous values were.\n        this._previousValue = Array.isArray(value) ? Array.from(value) : value;\n        const r = this.render(value, f);\n        return r;\n    }\n}\n/**\n * Prevents re-render of a template function until a single value or an array of\n * values changes.\n *\n * Values are checked against previous values with strict equality (`===`), and\n * so the check won't detect nested property changes inside objects or arrays.\n * Arrays values have each item checked against the previous value at the same\n * index with strict equality. Nested arrays are also checked only by strict\n * equality.\n *\n * Example:\n *\n * ```js\n * html`\n *   <div>\n *     ${guard([user.id, company.id], () => html`...`)}\n *   </div>\n * `\n * ```\n *\n * In this case, the template only rerenders if either `user.id` or `company.id`\n * changes.\n *\n * guard() is useful with immutable data patterns, by preventing expensive work\n * until data updates.\n *\n * Example:\n *\n * ```js\n * html`\n *   <div>\n *     ${guard([immutableItems], () => immutableItems.map(i => html`${i}`))}\n *   </div>\n * `\n * ```\n *\n * In this case, items are mapped over only when the array reference changes.\n *\n * @param value the value to check before re-rendering\n * @param f the template function\n */\nexport const guard = directive(GuardDirective);\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,SAASA,QAAQ,QAAQ,gBAAgB;AACzC,SAASC,SAAS,EAAEC,SAAS,QAAQ,iBAAiB;AACtD;AACA,MAAMC,YAAY,GAAG,CAAC,CAAC;AACvB,MAAMC,cAAc,SAASF,SAAS,CAAC;EACnCG,WAAW,GAAG;IACV,KAAK,CAAC,GAAGC,SAAS,CAAC;IACnB,IAAI,CAACC,cAAc,GAAGJ,YAAY;EACtC;EACAK,MAAM,CAACC,MAAM,EAAEC,CAAC,EAAE;IACd,OAAOA,CAAC,EAAE;EACd;EACAC,MAAM,CAACC,KAAK,EAAE,CAACC,KAAK,EAAEH,CAAC,CAAC,EAAE;IACtB,IAAII,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,EAAE;MACtB;MACA,IAAIC,KAAK,CAACC,OAAO,CAAC,IAAI,CAACR,cAAc,CAAC,IAClC,IAAI,CAACA,cAAc,CAACS,MAAM,KAAKH,KAAK,CAACG,MAAM,IAC3CH,KAAK,CAACI,KAAK,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,KAAK,IAAI,CAACX,cAAc,CAACY,CAAC,CAAC,CAAC,EAAE;QACrD,OAAOnB,QAAQ;MACnB;IACJ,CAAC,MACI,IAAI,IAAI,CAACO,cAAc,KAAKM,KAAK,EAAE;MACpC;MACA,OAAOb,QAAQ;IACnB;IACA;IACA;IACA,IAAI,CAACO,cAAc,GAAGO,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,GAAGC,KAAK,CAACM,IAAI,CAACP,KAAK,CAAC,GAAGA,KAAK;IACtE,MAAMQ,CAAC,GAAG,IAAI,CAACb,MAAM,CAACK,KAAK,EAAEH,CAAC,CAAC;IAC/B,OAAOW,CAAC;EACZ;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,KAAK,GAAGrB,SAAS,CAACG,cAAc,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}