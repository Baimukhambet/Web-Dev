{"ast":null,"code":"const FLAGS = new Set('aACL09#&?');\nconst REGEX = new Map([['C', /(?!^$)/u], ['&', /[^\\p{Separator}]/u], ['a', /[\\p{Letter}\\d\\p{Separator}]/u], ['A', /[\\p{Letter}\\d]/u], ['?', /[\\p{Letter}\\p{Separator}]/u], ['L', /\\p{Letter}/u], ['0', /\\d/], ['9', /[\\d\\p{Separator}]/u], ['#', /[\\d\\-+]/]]);\nconst REQUIRED = new Set('0#LA&');\nconst replaceIMENumbers = string => {\n  return string.replace(/[０１２３４５６７８９]/g, num => ({\n    '１': '1',\n    '２': '2',\n    '３': '3',\n    '４': '4',\n    '５': '5',\n    '６': '6',\n    '７': '7',\n    '８': '8',\n    '９': '9',\n    '０': '0'\n  })[num]);\n};\nexport class MaskParser {\n  constructor(options = {\n    format: 'CCCCCCCCCC',\n    promptCharacter: '_'\n  }) {\n    this.literals = new Map();\n    this.options = options;\n  }\n  get literalPositions() {\n    this.getMaskLiterals();\n    return Array.from(this.literals.keys());\n  }\n  get escapedMask() {\n    this.getMaskLiterals();\n    return this._escapedMask;\n  }\n  get mask() {\n    return this.options.format;\n  }\n  set mask(value) {\n    this.options.format = value || this.options.format;\n    this.getMaskLiterals();\n  }\n  get prompt() {\n    return this.options.promptCharacter;\n  }\n  set prompt(value) {\n    this.options.promptCharacter = value ? value.substring(0, 1) : this.options.promptCharacter;\n  }\n  getMaskLiterals() {\n    this.literals.clear();\n    this._escapedMask = this.mask;\n    for (let i = 0, j = 0; i < this.mask.length; i++, j++) {\n      const [current, next] = [this.mask.charAt(i), this.mask.charAt(i + 1)];\n      if (current === '\\\\' && FLAGS.has(next)) {\n        this._escapedMask = this.replaceCharAt(this._escapedMask, j, '');\n        this.literals.set(j, next);\n        i++;\n      } else {\n        if (!FLAGS.has(current)) {\n          this.literals.set(j, current);\n        }\n      }\n    }\n  }\n  isPromptChar(char) {\n    return char === this.prompt;\n  }\n  replaceCharAt(string, pos, char) {\n    return `${string.substring(0, pos)}${char}${string.substring(pos + 1)}`;\n  }\n  validate(char, maskedChar) {\n    const regex = REGEX.get(maskedChar);\n    return regex ? regex.test(char) : false;\n  }\n  getNonLiteralPositions(mask = '') {\n    const positions = this.literalPositions;\n    return Array.from(mask).map((_, pos) => !positions.includes(pos) ? pos : -1).filter(pos => pos > -1);\n  }\n  getRequiredNonLiteralPositions(mask) {\n    const positions = this.literalPositions;\n    return Array.from(mask).map((char, pos) => REQUIRED.has(char) && !positions.includes(pos) ? pos : -1).filter(pos => pos > -1);\n  }\n  getPreviousNonLiteralPosition(start) {\n    const positions = this.literalPositions;\n    for (let i = start; i > 0; i--) {\n      if (!positions.includes(i)) return i;\n    }\n    return start;\n  }\n  getNextNonLiteralPosition(start) {\n    const positions = this.literalPositions;\n    for (let i = start; i < this._escapedMask.length; i++) {\n      if (!positions.includes(i)) return i;\n    }\n    return start;\n  }\n  replace(masked = '', value, start, end) {\n    const chars = Array.from(replaceIMENumbers(value));\n    const positions = this.literalPositions;\n    end = Math.min(end, masked.length);\n    let cursor = start;\n    for (let i = start; i < end || chars.length && i < masked.length; i++) {\n      if (positions.includes(i)) {\n        if (chars[0] === masked[i]) {\n          cursor = i + 1;\n          chars.shift();\n        }\n        continue;\n      }\n      if (chars[0] && !this.validate(chars[0], this._escapedMask[i]) && !this.isPromptChar(chars[0])) {\n        break;\n      }\n      let char = this.prompt;\n      if (chars.length) {\n        cursor = i + 1;\n        char = chars.shift();\n      }\n      masked = this.replaceCharAt(masked, i, char);\n    }\n    return {\n      value: masked,\n      end: cursor\n    };\n  }\n  parse(masked = '') {\n    return Array.from(masked).reduce((prev, char, pos) => {\n      return `${prev}${!this.literalPositions.includes(pos) && !this.isPromptChar(char) ? char : ''}`;\n    }, '');\n  }\n  isValidString(input = '') {\n    const required = this.getRequiredNonLiteralPositions(this._escapedMask);\n    if (required.length > this.parse(input).length) {\n      return false;\n    }\n    return required.every(pos => {\n      const char = input.charAt(pos);\n      return char !== undefined && this.validate(char, this._escapedMask.charAt(pos)) && !this.isPromptChar(char);\n    });\n  }\n  apply(input = '') {\n    const nonLiteralPositions = this.getNonLiteralPositions(this._escapedMask);\n    let output = new Array(this._escapedMask.length).fill(this.prompt).join('');\n    this.literals.forEach((char, pos) => {\n      output = this.replaceCharAt(output, pos, char);\n    });\n    if (!input) {\n      return output;\n    }\n    const values = nonLiteralPositions.map((pos, index) => {\n      const char = input.charAt(index);\n      return !this.validate(char, this._escapedMask.charAt(pos)) && !this.isPromptChar(char) ? this.prompt : char;\n    });\n    if (values.length > nonLiteralPositions.length) {\n      values.splice(nonLiteralPositions.length);\n    }\n    let pos = 0;\n    for (const each of values) {\n      output = this.replaceCharAt(output, nonLiteralPositions[pos++], each);\n    }\n    return output;\n  }\n}","map":{"version":3,"names":["FLAGS","Set","REGEX","Map","REQUIRED","replaceIMENumbers","string","replace","num","MaskParser","constructor","options","format","promptCharacter","literals","literalPositions","getMaskLiterals","Array","from","keys","escapedMask","_escapedMask","mask","value","prompt","substring","clear","i","j","length","current","next","charAt","has","replaceCharAt","set","isPromptChar","char","pos","validate","maskedChar","regex","get","test","getNonLiteralPositions","positions","map","_","includes","filter","getRequiredNonLiteralPositions","getPreviousNonLiteralPosition","start","getNextNonLiteralPosition","masked","end","chars","Math","min","cursor","shift","parse","reduce","prev","isValidString","input","required","every","undefined","apply","nonLiteralPositions","output","fill","join","forEach","values","index","splice","each"],"sources":["/Users/tima/kbtu/4thSemester/web/Lab4/angular/node_modules/igniteui-webcomponents/components/mask-input/mask-parser.js"],"sourcesContent":["const FLAGS = new Set('aACL09#&?');\nconst REGEX = new Map([\n    ['C', /(?!^$)/u],\n    ['&', /[^\\p{Separator}]/u],\n    ['a', /[\\p{Letter}\\d\\p{Separator}]/u],\n    ['A', /[\\p{Letter}\\d]/u],\n    ['?', /[\\p{Letter}\\p{Separator}]/u],\n    ['L', /\\p{Letter}/u],\n    ['0', /\\d/],\n    ['9', /[\\d\\p{Separator}]/u],\n    ['#', /[\\d\\-+]/],\n]);\nconst REQUIRED = new Set('0#LA&');\nconst replaceIMENumbers = (string) => {\n    return string.replace(/[０１２３４５６７８９]/g, (num) => ({\n        '１': '1',\n        '２': '2',\n        '３': '3',\n        '４': '4',\n        '５': '5',\n        '６': '6',\n        '７': '7',\n        '８': '8',\n        '９': '9',\n        '０': '0',\n    }[num]));\n};\nexport class MaskParser {\n    constructor(options = { format: 'CCCCCCCCCC', promptCharacter: '_' }) {\n        this.literals = new Map();\n        this.options = options;\n    }\n    get literalPositions() {\n        this.getMaskLiterals();\n        return Array.from(this.literals.keys());\n    }\n    get escapedMask() {\n        this.getMaskLiterals();\n        return this._escapedMask;\n    }\n    get mask() {\n        return this.options.format;\n    }\n    set mask(value) {\n        this.options.format = value || this.options.format;\n        this.getMaskLiterals();\n    }\n    get prompt() {\n        return this.options.promptCharacter;\n    }\n    set prompt(value) {\n        this.options.promptCharacter = value\n            ? value.substring(0, 1)\n            : this.options.promptCharacter;\n    }\n    getMaskLiterals() {\n        this.literals.clear();\n        this._escapedMask = this.mask;\n        for (let i = 0, j = 0; i < this.mask.length; i++, j++) {\n            const [current, next] = [this.mask.charAt(i), this.mask.charAt(i + 1)];\n            if (current === '\\\\' && FLAGS.has(next)) {\n                this._escapedMask = this.replaceCharAt(this._escapedMask, j, '');\n                this.literals.set(j, next);\n                i++;\n            }\n            else {\n                if (!FLAGS.has(current)) {\n                    this.literals.set(j, current);\n                }\n            }\n        }\n    }\n    isPromptChar(char) {\n        return char === this.prompt;\n    }\n    replaceCharAt(string, pos, char) {\n        return `${string.substring(0, pos)}${char}${string.substring(pos + 1)}`;\n    }\n    validate(char, maskedChar) {\n        const regex = REGEX.get(maskedChar);\n        return regex ? regex.test(char) : false;\n    }\n    getNonLiteralPositions(mask = '') {\n        const positions = this.literalPositions;\n        return Array.from(mask)\n            .map((_, pos) => (!positions.includes(pos) ? pos : -1))\n            .filter((pos) => pos > -1);\n    }\n    getRequiredNonLiteralPositions(mask) {\n        const positions = this.literalPositions;\n        return Array.from(mask)\n            .map((char, pos) => REQUIRED.has(char) && !positions.includes(pos) ? pos : -1)\n            .filter((pos) => pos > -1);\n    }\n    getPreviousNonLiteralPosition(start) {\n        const positions = this.literalPositions;\n        for (let i = start; i > 0; i--) {\n            if (!positions.includes(i))\n                return i;\n        }\n        return start;\n    }\n    getNextNonLiteralPosition(start) {\n        const positions = this.literalPositions;\n        for (let i = start; i < this._escapedMask.length; i++) {\n            if (!positions.includes(i))\n                return i;\n        }\n        return start;\n    }\n    replace(masked = '', value, start, end) {\n        const chars = Array.from(replaceIMENumbers(value));\n        const positions = this.literalPositions;\n        end = Math.min(end, masked.length);\n        let cursor = start;\n        for (let i = start; i < end || (chars.length && i < masked.length); i++) {\n            if (positions.includes(i)) {\n                if (chars[0] === masked[i]) {\n                    cursor = i + 1;\n                    chars.shift();\n                }\n                continue;\n            }\n            if (chars[0] &&\n                !this.validate(chars[0], this._escapedMask[i]) &&\n                !this.isPromptChar(chars[0])) {\n                break;\n            }\n            let char = this.prompt;\n            if (chars.length) {\n                cursor = i + 1;\n                char = chars.shift();\n            }\n            masked = this.replaceCharAt(masked, i, char);\n        }\n        return { value: masked, end: cursor };\n    }\n    parse(masked = '') {\n        return Array.from(masked).reduce((prev, char, pos) => {\n            return `${prev}${!this.literalPositions.includes(pos) && !this.isPromptChar(char)\n                ? char\n                : ''}`;\n        }, '');\n    }\n    isValidString(input = '') {\n        const required = this.getRequiredNonLiteralPositions(this._escapedMask);\n        if (required.length > this.parse(input).length) {\n            return false;\n        }\n        return required.every((pos) => {\n            const char = input.charAt(pos);\n            return (char !== undefined &&\n                this.validate(char, this._escapedMask.charAt(pos)) &&\n                !this.isPromptChar(char));\n        });\n    }\n    apply(input = '') {\n        const nonLiteralPositions = this.getNonLiteralPositions(this._escapedMask);\n        let output = new Array(this._escapedMask.length).fill(this.prompt).join('');\n        this.literals.forEach((char, pos) => {\n            output = this.replaceCharAt(output, pos, char);\n        });\n        if (!input) {\n            return output;\n        }\n        const values = nonLiteralPositions.map((pos, index) => {\n            const char = input.charAt(index);\n            return !this.validate(char, this._escapedMask.charAt(pos)) &&\n                !this.isPromptChar(char)\n                ? this.prompt\n                : char;\n        });\n        if (values.length > nonLiteralPositions.length) {\n            values.splice(nonLiteralPositions.length);\n        }\n        let pos = 0;\n        for (const each of values) {\n            output = this.replaceCharAt(output, nonLiteralPositions[pos++], each);\n        }\n        return output;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}